<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Backbone.nestedtypes : Backbone.js extension adding native properties for models, defaults&#39; type annotations, nested models and collections.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Backbone.nestedtypes</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/Volicon/backbone.nestedTypes">View on GitHub</a>

          <h1 id="project_title">Backbone.nestedtypes</h1>
          <h2 id="project_tagline">Backbone.js extension adding native properties for models, defaults&#39; type annotations, nested models and collections.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/Volicon/backbone.nestedTypes/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/Volicon/backbone.nestedTypes/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>IMPORTANT. There changes in verion 9.x which is not compatible with previous versions. Following changes in code will be required:</p>

<ul>
<li>NestedTypes.Attribute({ ... }) -&gt; NestedTypes.options({ ... })</li>
<li>NestedTypes.Attribute( Type, value ) -&gt; Type.value( value )</li>
</ul>

<p>See "Attribute options" section for details on new type annotation syntax.</p>

<h1>
<a name="backbonenestedtypes" class="anchor" href="#backbonenestedtypes"><span class="octicon octicon-link"></span></a>backbone.nestedTypes</h1>

<p>NestedTypes is the type system for JavaScript, implemented on top of  Backbone. It solve common architectural problems of Backbone applications, providing simple yet powerful tools to deal with complex nested data structures. Brief feature list:</p>

<ul>
<li>Class type</li>
<li>
<em>Native properties</em> for Model attributes, Collection, and Class.</li>
<li>Inline Collection definition syntax for Models.</li>
<li>Model.defaults inheritance and deep copying.</li>
<li>Type declarations and automatic type casts for Model attributes.</li>
<li>Easy handling of Date attributes.</li>
<li>
<em>Nested models</em> and collections.</li>
<li>
<em>One-to-many</em> and <em>many-to-many</em> models relations.</li>
<li>'change' event bubbling for nested models and collections.</li>
<li>Attribute-level control for parse/toJSON and event bubbling.</li>
<li>Run-time type error detection and logging.</li>
</ul>

<h2>
<a name="how-it-feels-like" class="anchor" href="#how-it-feels-like"><span class="octicon octicon-link"></span></a>How it feels like</h2>

<p>It feels much like statically typed programming language. Yet, it's vanilla JavaScript.</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">urlRoot</span> <span class="o">:</span> <span class="s1">'/api/users'</span><span class="p">,</span>

    <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
        <span class="c1">// Primitive types</span>
        <span class="nx">login</span>    <span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="c1">// = ""</span>
        <span class="nx">email</span>    <span class="o">:</span> <span class="nb">String</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span> <span class="kc">null</span> <span class="p">),</span> <span class="c1">// = null</span>
        <span class="nx">loginCount</span> <span class="o">:</span> <span class="nb">Number</span><span class="p">.</span><span class="nx">options</span><span class="p">({</span> <span class="nx">toJSON</span> <span class="o">:</span> <span class="kc">false</span> <span class="p">})</span> <span class="c1">// = 0, not serialized</span>
        <span class="nx">active</span>   <span class="o">:</span> <span class="nb">Boolean</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span> <span class="kc">true</span> <span class="p">),</span> <span class="c1">// = true</span>

        <span class="nx">created</span>  <span class="o">:</span> <span class="nb">Date</span><span class="p">,</span> <span class="c1">// = new Date()</span>

        <span class="nx">settings</span> <span class="o">:</span> <span class="nx">Settings</span><span class="p">,</span> <span class="c1">// nested model</span>

        <span class="c1">// collection of models, received as an array of model ids</span>
        <span class="nx">roles</span>    <span class="o">:</span> <span class="nx">Role</span><span class="p">.</span><span class="nx">Collection</span><span class="p">.</span><span class="nx">SubsetOf</span><span class="p">(</span> <span class="nx">rolesCollection</span> <span class="p">),</span>
        <span class="c1">// reference to model, received as model id.</span>
        <span class="nx">office</span> <span class="o">:</span> <span class="nx">Office</span><span class="p">.</span><span class="nx">From</span><span class="p">(</span> <span class="nx">officeCollection</span> <span class="p">)</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">collection</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">.</span><span class="nx">Collection</span><span class="p">();</span> <span class="c1">// Collection is already there...</span>
<span class="nx">collection</span><span class="p">.</span><span class="nx">fetch</span><span class="p">().</span><span class="nx">done</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="nx">collection</span><span class="p">.</span><span class="nx">first</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="p">);</span> <span class="c1">// native properties</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">office</span><span class="p">.</span><span class="nx">name</span> <span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">roles</span><span class="p">.</span><span class="nx">first</span><span class="p">().</span><span class="nx">name</span> <span class="p">);</span>
<span class="p">});</span>
</pre></div>

<p>Types are being checked in run-time on assignment, but instead of throwing exceptions it tries to cast values to defined types. For example:</p>

<div class="highlight highlight-javascript"><pre>    <span class="nx">user</span><span class="p">.</span><span class="nx">login</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">login</span> <span class="o">===</span> <span class="s2">"1"</span> <span class="p">);</span>

    <span class="nx">user</span><span class="p">.</span><span class="nx">active</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">active</span> <span class="o">===</span> <span class="kc">false</span> <span class="p">);</span>

    <span class="nx">user</span><span class="p">.</span><span class="nx">loginCount</span> <span class="o">=</span> <span class="s2">"hjkhjkhfjkhjkfd"</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nx">isNan</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">loginCount</span> <span class="p">)</span> <span class="p">);</span>

    <span class="nx">user</span><span class="p">.</span><span class="nx">settings</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">timeZone</span> <span class="o">:</span> <span class="mi">180</span> <span class="p">};</span> <span class="c1">// same as user.settings.set({ timeZone : 180 })</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">settings</span> <span class="k">instanceof</span> <span class="nx">Settings</span> <span class="p">);</span>
</pre></div>

<h2>
<a name="requirements--installation" class="anchor" href="#requirements--installation"><span class="octicon octicon-link"></span></a>Requirements &amp; Installation</h2>

<p>All modern browsers and IE9+ are supported. To install, type</p>

<pre><code>bower install backbone.nested-types
</code></pre>

<p>or</p>

<pre><code>npm install backbone.nested-types
</code></pre>

<p>or just copy 'nestedtypes.js' file to desired location.</p>

<p>NestedTypes is compatible with node.js, CommonJS/AMD (e.g. RequireJS) module loaders, and could be included with plain script tag as well. To include it, use</p>

<pre><code>var NestedTypes = require( 'nestedtypes');
</code></pre>

<p>or</p>

<pre><code>require([ 'nestedtypes' ], function( NestedTypes ){
</code></pre>

<p>or</p>

<pre><code>&lt;script src="nestedtypes.js" type="text/javascript"&gt;&lt;/script&gt;
</code></pre>

<h1>
<a name="api-reference" class="anchor" href="#api-reference"><span class="octicon octicon-link"></span></a>API Reference</h1>

<h2>
<a name="basic-features" class="anchor" href="#basic-features"><span class="octicon octicon-link"></span></a>Basic features</h2>

<h3>
<a name="modeldefaults" class="anchor" href="#modeldefaults"><span class="octicon octicon-link"></span></a>Model.defaults:</h3>

<ul>
<li>Native properties are created for every entry.</li>
<li>Entries are inherited from the base Model.defaults.</li>
<li>JSON literals will be deep copied upon creation of model.</li>
<li>defaults <em>must</em> be an object, functions are not supported.</li>
<li>attributes <em>must</em> be declared in defaults.</li>
</ul>

<div class="highlight highlight-javascript"><pre>    <span class="kd">var</span> <span class="nx">UserInfo</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
        <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
            <span class="nx">name</span> <span class="o">:</span> <span class="s1">'test'</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="kd">var</span> <span class="nx">DetailedUserInfo</span> <span class="o">=</span> <span class="nx">UserInfo</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
        <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
            <span class="nx">login</span> <span class="o">:</span> <span class="s1">''</span><span class="p">,</span>
            <span class="nx">roles</span> <span class="o">:</span> <span class="p">[</span> <span class="s1">'user'</span> <span class="p">]</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DetailedUserInfo</span><span class="p">();</span>

    <span class="c1">// user.get( 'name' ) would be undefined in plain Backbone.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="s1">'test'</span> <span class="p">);</span> <span class="c1">// you still can use 'get', but why...</span>
    <span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="s1">'admin'</span><span class="p">;</span>

    <span class="c1">// In Backbone all models will share the same instance of [ 'user' ] array.</span>
    <span class="c1">// So, following line will create a bug. Not in NestedTypes.</span>
    <span class="nx">user</span><span class="p">.</span><span class="nx">roles</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span> <span class="s1">'admin'</span> <span class="p">);</span>
</pre></div>

<h3>
<a name="inline-collection-definition-modelcollection" class="anchor" href="#inline-collection-definition-modelcollection"><span class="octicon octicon-link"></span></a>Inline collection definition (Model.collection).</h3>

<p>By the way, our models from previous example has collections defined already.</p>

<div class="highlight highlight-javascript"><pre>    <span class="kd">var</span> <span class="nx">users</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">UserInfo</span><span class="p">.</span><span class="nx">Collection</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">detailedUsers</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">DetailedUserInfo</span><span class="p">.</span><span class="nx">Collection</span><span class="p">();</span>
</pre></div>

<p>Every model definition creates Collection type extending base Model.Collection.  Collection.model and Collection.url properties are taken from model. You could customize collection with a spec in Model.collection, which then will be passed to BaseModel.Collection.extend.</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">DetailedUserInfo</span> <span class="o">=</span> <span class="nx">UserInfo</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">urlBase</span> <span class="o">:</span> <span class="s1">'/api/detailed_user/'</span><span class="p">,</span>

    <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
        <span class="nx">login</span> <span class="o">:</span> <span class="s1">''</span><span class="p">,</span>
        <span class="nx">roles</span> <span class="o">:</span> <span class="p">[</span> <span class="s1">'user'</span> <span class="p">]</span>
    <span class="p">},</span>

    <span class="nx">collection</span> <span class="o">:</span> <span class="p">{</span>
        <span class="nx">initialize</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">fetch</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="cm">/*</span>
<span class="cm">    DetailedUserInfo.Collection = UserInfo.Collection.extend({</span>
<span class="cm">        url : '/api/detailed_user/',</span>
<span class="cm">        model : DetailedUserInfo,</span>

<span class="cm">        initialize: function(){</span>
<span class="cm">            this.fetch();</span>
<span class="cm">        }</span>
<span class="cm">    });</span>
<span class="cm">*/</span>
</pre></div>

<h3>
<a name="class-type-which-can-be-extended-and-can-throwlisten-to-events" class="anchor" href="#class-type-which-can-be-extended-and-can-throwlisten-to-events"><span class="octicon octicon-link"></span></a>Class type, which can be extended and can throw/listen to events.</h3>

<div class="highlight highlight-javascript"><pre>    <span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Class</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
        <span class="nx">a</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>

        <span class="nx">initialize</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">options</span> <span class="p">){</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">listenTo</span><span class="p">(</span> <span class="nx">options</span><span class="p">.</span><span class="nx">other</span><span class="p">,</span> <span class="s1">'event'</span><span class="p">,</span> <span class="nx">doSomething</span> <span class="p">)</span>
        <span class="p">},</span>

        <span class="nx">doSomething</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">trigger</span><span class="p">(</span> <span class="s1">'something'</span> <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="kd">var</span> <span class="nx">B</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
        <span class="nx">b</span> <span class="o">:</span> <span class="mi">2</span><span class="p">,</span>

        <span class="nx">initialize</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">options</span> <span class="p">){</span>
            <span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">initialize</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span> <span class="k">this</span><span class="p">,</span> <span class="nx">arguments</span> <span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">listenTo</span><span class="p">(</span> <span class="nx">options</span><span class="p">.</span><span class="nx">another</span><span class="p">,</span> <span class="s1">'event'</span><span class="p">,</span> <span class="nx">doSomething</span> <span class="p">)</span>
        <span class="p">},</span>
    <span class="p">});</span>

    <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">B</span><span class="p">(</span> <span class="nx">options</span> <span class="p">);</span>
</pre></div>

<h3>
<a name="explicit-native-properties-definition-model-class-collection" class="anchor" href="#explicit-native-properties-definition-model-class-collection"><span class="octicon octicon-link"></span></a>Explicit native properties definition (Model, Class, Collection).</h3>

<p>Native properties are generated for model attributes, however, they also can be defined explicitly for Model, Class, Collection with 'properties' specification.</p>

<p>For Model, explicit property will override generated one, and "properties : false" disable defaults native properties generation.</p>

<div class="highlight highlight-javascript"><pre>    <span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
        <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
            <span class="nx">a</span> <span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
            <span class="nx">b</span> <span class="o">:</span> <span class="mi">2</span>
        <span class="p">},</span>

        <span class="nx">properties</span> <span class="o">:</span> <span class="p">{</span>
            <span class="nx">c</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
                <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span><span class="p">;</span>
            <span class="p">},</span>

            <span class="nx">ax2</span> <span class="o">:</span> <span class="p">{</span>
                <span class="nx">get</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
                    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
                <span class="p">},</span>

                <span class="nx">set</span> <span class="o">:</span> <span class="kd">function</span><span class="p">(</span> <span class="nx">value</span> <span class="p">){</span>
                    <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">value</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                    <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">c</span> <span class="o">===</span> <span class="mi">3</span> <span class="p">);</span>

    <span class="nx">a</span><span class="p">.</span><span class="nx">ax2</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">c</span> <span class="o">===</span> <span class="mi">2</span> <span class="p">);</span>
</pre></div>

<h3>
<a name="run-time-errors" class="anchor" href="#run-time-errors"><span class="octicon octicon-link"></span></a>Run-time errors</h3>

<p>NestedTypes detect four error types in the runtime, which will be logged to console using console.error.</p>

<pre><code>[Type error](Model.extend) Property "name" conflicts with base class members.
</code></pre>

<p>It's forbidden for native properties to override members of the base Model. Since native properties are generated for Model.defaults elements, its also forbidden to have attribute names which are the same as members of the base Model.</p>

<pre><code>[Type Error](Model.set) Attribute hash is not an object: ...
</code></pre>

<p>First argument of Model.set must be either string, or literal object representing attribute hash.</p>

<pre><code>[Type Error](Model.set) Attribute "name" has no default value.
</code></pre>

<p>Attempt to set attribute which is not declared in defaults.</p>

<pre><code>[Type Error](Model.defaults) "defaults" must be an object, functions are not supported
</code></pre>

<h2>
<a name="modeldefaults-type-specs" class="anchor" href="#modeldefaults-type-specs"><span class="octicon octicon-link"></span></a>Model.defaults Type Specs</h2>

<h3>
<a name="basic-type-annotation-syntax-and-rules" class="anchor" href="#basic-type-annotation-syntax-and-rules"><span class="octicon octicon-link"></span></a>Basic type annotation syntax and rules</h3>

<p>Type specs can be optionally used instead of init values in Model.defaults. They looks like this:</p>

<pre><code>name : Constructor
</code></pre>

<p>or</p>

<pre><code>name : Constructor.value( x )
</code></pre>

<p>where Constructor is JS constructor function, and x is its default value.</p>

<p>When default value is not specified, typed attribute is initialized invoking 'new Constructor()'.</p>

<p>As a general rule, when typed attribute is assigned with the value...</p>

<ul>
<li>which is null, attribute will be set to null.</li>
<li>which is an instance of Constructor, attribute's value will be replaced.</li>
<li>in other case, NestedTypes will try to convert value to the Constructor type, typically invoking "new Constructor( value )". This type conversion algorithm may be overriden for some selected types.</li>
</ul>

<p>When receiving data from server, type cast logic is used to parse JSON responce; typically you don't need to override Model.parse.</p>

<p>When sending data to the server, Constructor.toJSON will be invoked to produce JSON for typed attributes, so you don't need to override Model.toJSON for that.</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
        <span class="nx">obj1</span> <span class="o">:</span> <span class="nx">Ctor</span><span class="p">,</span> <span class="c1">// = new Ctor()</span>
        <span class="nx">obj2</span> <span class="o">:</span> <span class="nx">Ctor</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span> <span class="kc">null</span> <span class="p">),</span> <span class="c1">// = null</span>
        <span class="nx">obj3</span> <span class="o">:</span> <span class="nx">Ctor</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span> <span class="nx">something</span> <span class="p">),</span> <span class="c1">// = new Ctor( something )</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">A</span><span class="p">();</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">obj2</span> <span class="o">=</span> <span class="s2">"dsds"</span><span class="p">;</span> <span class="c1">// a.obj2 = new Ctor( "dsds" );</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">obj2</span> <span class="k">instanceof</span> <span class="nx">Ctor</span> <span class="p">);</span>
</pre></div>

<h3>
<a name="primitive-types-boolean-number-string" class="anchor" href="#primitive-types-boolean-number-string"><span class="octicon octicon-link"></span></a>Primitive types (Boolean, Number, String)</h3>

<p>Primitive types are special in a sense that <em>they are infered from their values</em>, so they are always typed. In most cases special type annotation syntax is not really required.</p>

<p>It means that if attribute has default value of 5 <em>then it's guaranteed to be Number or null</em> (it will be casted to Number on assignments). This is quite different from original Backbone's behaviour which you might expect, and it makes models safer. For polimorphic attributes holding different types you can disable type inference using 'NestedTypes.value'.</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
        <span class="c1">// Original backbone behaviour - no type, value is 3232</span>
        <span class="nx">untyped</span> <span class="o">:</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span> <span class="mi">3232</span> <span class="p">)</span>

        <span class="c1">// defaults with primitive types are always 'typed'</span>
        <span class="nx">number</span>  <span class="o">:</span> <span class="mi">5</span><span class="p">,</span>           <span class="c1">// same as Number.value( 5 )</span>
        <span class="nx">string</span>  <span class="o">:</span> <span class="s1">'something'</span><span class="p">,</span> <span class="c1">// same as String.value( 'something' )</span>
        <span class="nx">string1</span> <span class="o">:</span> <span class="s1">''</span><span class="p">,</span>          <span class="c1">// same as String</span>
        <span class="kr">boolean</span> <span class="o">:</span> <span class="kc">true</span><span class="p">,</span>        <span class="c1">// same as Boolean.value( true )</span>

        <span class="nx">initWithNull</span>  <span class="o">:</span> <span class="nb">String</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span> <span class="kc">null</span> <span class="p">),</span> <span class="c1">// Type is String, default value is null</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">A</span><span class="p">();</span>

<span class="nx">a</span><span class="p">.</span><span class="kr">boolean</span> <span class="o">=</span> <span class="s2">"hello"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="kr">boolean</span> <span class="o">===</span> <span class="kc">true</span> <span class="p">);</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="s2">"5"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">number</span> <span class="o">===</span> <span class="mi">5</span> <span class="p">);</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="s2">"hjhjfd"</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">_</span><span class="p">.</span><span class="nb">isNaN</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">number</span> <span class="p">)</span> <span class="p">);</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">string</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">string</span> <span class="o">===</span> <span class="s2">"5"</span> <span class="p">);</span>

<span class="nx">a</span><span class="p">.</span><span class="kr">boolean</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="kr">boolean</span> <span class="o">===</span> <span class="kc">false</span> <span class="p">);</span>
</pre></div>

<h3>
<a name="date-type" class="anchor" href="#date-type"><span class="octicon octicon-link"></span></a>Date type</h3>

<ul>
<li>Automatic parsing of common JSON date representations.</li>
<li>Automatically serialized to ISO string (don't need to override toJSON)</li>
</ul>

<p>Date attributes free you from overriding Model.parse or Model.toJSON when you want to transfer dates between server and client.</p>

<p>Strings and numbers will be converted to date with Date constructor. NestedTypes contains additional logic to implement cross-browser ISO date parsing and handling of MS date format.</p>

<p>On serialization, Date.toJSON will be invoked for date attribute, producing UTC-0 ISO date string representation.</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">A</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
        <span class="nx">created</span> <span class="o">:</span> <span class="nb">Date</span><span class="p">,</span> <span class="c1">// = new Date()</span>
        <span class="nx">updated</span> <span class="o">:</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span> <span class="kc">null</span> <span class="p">),</span> <span class="c1">// = null</span>
        <span class="nx">a</span> <span class="o">:</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span> <span class="mi">327943789</span> <span class="p">),</span> <span class="c1">//  = new Date( 327943789 )</span>
        <span class="nx">b</span> <span class="o">:</span> <span class="nb">Date</span><span class="p">.</span><span class="nx">value</span><span class="p">(</span> <span class="s2">"2012-12-12 12:12"</span> <span class="p">)</span> <span class="c1">//  = new Date( "2012-12-12 12:12" )</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">A</span><span class="p">();</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">updated</span> <span class="o">=</span> <span class="s1">'2012-12-12 12:12'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">updated</span> <span class="k">instanceof</span> <span class="nb">Date</span> <span class="p">);</span>

<span class="nx">a</span><span class="p">.</span><span class="nx">updated</span> <span class="o">=</span> <span class="s1">'/Date(32323232323)/'</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">assert</span><span class="p">(</span> <span class="nx">a</span><span class="p">.</span><span class="nx">updated</span> <span class="k">instanceof</span> <span class="nb">Date</span> <span class="p">);</span>
</pre></div>

<h3>
<a name="nested-models-and-collections" class="anchor" href="#nested-models-and-collections"><span class="octicon octicon-link"></span></a>Nested Models and Collections</h3>

<ul>
<li>automatic parsing and serialization</li>
<li>'deep updates' and 'deep clone'</li>
<li>'change' event bubbling</li>
</ul>

<p>To define nested model or collection, just annotate attributes with Model or Collection type.</p>

<p>Note, that Backbone's .clone() method will create shallow copy of the root model, while Model.deepClone() and Collection.deepClone() will clone model and collection with all subitems.</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
        <span class="nx">name</span>        <span class="o">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="nx">created</span>     <span class="o">:</span> <span class="nb">Date</span><span class="p">,</span>
        <span class="nx">group</span>       <span class="o">:</span> <span class="nx">GroupModel</span><span class="p">,</span>
        <span class="nx">permissions</span> <span class="o">:</span> <span class="nx">PermissionCollection</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">(),</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">deepClone</span><span class="p">();</span>
</pre></div>

<p>Model/Collection type cast behavior depends on attribute value before assignment:</p>

<ul>
<li>If attribute value is null, Model/Collection constructor will be invoked as for usual types.</li>
<li>If attribute already holds model or collection, <em>deep update</em> will be performed instead.</li>
</ul>

<p>"Deep update" means that model/collection object itself will remain in place, and 'set' method will be used to perform an update.</p>

<p>I.e. this code:</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">();</span>
<span class="nx">user</span><span class="p">.</span><span class="nx">group</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="o">:</span> <span class="s2">"Admin"</span>
<span class="p">};</span>

<span class="nx">user</span><span class="p">.</span><span class="nx">permissions</span> <span class="o">=</span> <span class="p">[{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">'full'</span> <span class="p">}];</span>
</pre></div>

<p>is equivalent of:</p>

<div class="highlight highlight-javascript"><pre><span class="nx">user</span><span class="p">.</span><span class="nx">group</span><span class="p">.</span><span class="nx">set</span><span class="p">({</span>
   <span class="nx">name</span><span class="o">:</span> <span class="s2">"Admin"</span>
<span class="p">};</span>

<span class="nx">user</span><span class="p">.</span><span class="nx">permissions</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span> <span class="p">[{</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nx">type</span><span class="o">:</span> <span class="s1">'full'</span> <span class="p">}]</span> <span class="p">);</span>
</pre></div>

<p>This mechanics of 'set' allows you to work with JSON from in case of deeply nested models and collections without the need to override 'parse'. This code (considering that nested attributes defined as models):</p>

<div class="highlight highlight-javascript"><pre><span class="nx">user</span><span class="p">.</span><span class="nx">group</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">nestedModel</span> <span class="o">:</span> <span class="p">{</span>
        <span class="nx">deeplyNestedModel</span> <span class="o">:</span> <span class="p">{</span>
            <span class="nx">attr</span> <span class="o">:</span> <span class="s1">'value'</span>
        <span class="p">},</span>

        <span class="nx">attr</span> <span class="o">:</span> <span class="mi">5</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>

<p>is almost equivalent of:</p>

<div class="highlight highlight-javascript"><pre><span class="nx">user</span><span class="p">.</span><span class="nx">group</span><span class="p">.</span><span class="nx">nestedModel</span><span class="p">.</span><span class="nx">deeplyNestedModel</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span> <span class="s1">'attr'</span><span class="p">,</span> <span class="s1">'value'</span> <span class="p">);</span>
<span class="nx">user</span><span class="p">.</span><span class="nx">group</span><span class="p">.</span><span class="nx">nestedModel</span><span class="p">.</span><span class="nx">set</span><span class="p">(</span> <span class="s1">'attr'</span><span class="p">,</span> <span class="s1">'value'</span> <span class="p">);</span>
</pre></div>

<p>but it will fire just single <code>change</code> event.</p>

<p>Change events will be bubbled from nested models and collections.</p>

<ul>
<li>
<code>change</code> and <code>change:attribute</code> events for any changes in nested models and collections. Multiple <code>change</code> events from submodels during bulk updates are carefully joined together, which make it suitable to subscribe View.render to the top model's <code>change</code>.</li>
<li>
<code>replace:attribute</code> event when model or collection is replaced with new object. You might need it to subscribe for events from submodels.</li>
<li>It's possible to control event bubbling for every attribute. You can completely disable it, or override the list of events which would be counted as change:</li>
</ul>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">M</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">bubbleChanges</span> <span class="o">:</span> <span class="nx">ModelOrCollection</span><span class="p">,</span>

        <span class="nx">dontBubble</span> <span class="o">:</span> <span class="nx">ModelOrCollection</span><span class="p">.</span><span class="nx">options</span><span class="p">({</span> <span class="nx">triggerWhanChanged</span> <span class="o">:</span> <span class="kc">false</span> <span class="p">})</span>
        <span class="p">}),</span>

        <span class="nx">bubbleCustomEvents</span> <span class="o">:</span> <span class="nx">ModelOrCollection</span><span class="p">.</span><span class="nx">options</span><span class="p">({</span>
            <span class="nx">triggerWhanChanged</span> <span class="o">:</span> <span class="s1">'event1 event2 whatever'</span>
        <span class="p">}),</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<h3>
<a name="model-relations" class="anchor" href="#model-relations"><span class="octicon octicon-link"></span></a>Model relations</h3>

<ul>
<li>Model.From</li>
<li>Collection.SubsetOf</li>
</ul>

<p>Sometimes when you have one-to-many and many-to-many relationships between Models, it is suitable to transfer such a relationships from server as arrays of model ids. NestedTypes gives you special attribute data types for this situation.</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
        <span class="nx">name</span> <span class="o">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="nx">roles</span> <span class="o">:</span> <span class="nx">RolesCollection</span><span class="p">.</span><span class="nx">SubsetOf</span><span class="p">(</span> <span class="nx">rolesCollection</span> <span class="p">)</span> <span class="c1">// &lt;- serialized as array of model ids</span>
        <span class="nx">location</span> <span class="o">:</span> <span class="nx">Location</span><span class="p">.</span><span class="nx">From</span><span class="p">(</span> <span class="nx">locationsCollection</span> <span class="p">)</span> <span class="c1">// &lt;- serialized as model id</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="kd">var</span> <span class="nx">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">({</span> <span class="nx">id</span><span class="o">:</span> <span class="mi">0</span> <span class="p">});</span>
<span class="nx">user</span><span class="p">.</span><span class="nx">fetch</span><span class="p">();</span> <span class="c1">// &lt;- you'll receive from server "{ id: 0, name : 'john', roles : [ 1, 2, 3 ] }"</span>
<span class="p">...</span>
<span class="c1">// however, user.roles behaves like normal collection of Roles.</span>
<span class="nx">assert</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">roles</span> <span class="k">instanceof</span> <span class="nx">Collection</span> <span class="p">);</span>
<span class="nx">assert</span><span class="p">(</span> <span class="nx">user</span><span class="p">.</span><span class="nx">roles</span><span class="p">.</span><span class="nx">first</span><span class="p">()</span> <span class="k">instanceof</span> <span class="nx">Role</span> <span class="p">);</span>
</pre></div>

<p>Collection.SubsetOf is a collection of models taken from existing collection. On first access of attribute of this type, it will resolve ids to real models from the given master collection.</p>

<p>If master collection is empty and thus references cannot be resolved, it will defer id resolution and just return collection of dummy models with ids. However, if master collection is not empty, it will filter out ids of non-existent models.</p>

<p>There are 'lazy' option for passing reference to master collection:</p>

<div class="highlight highlight-javascript"><pre><span class="kd">var</span> <span class="nx">User</span> <span class="o">=</span> <span class="nx">NestedTypes</span><span class="p">.</span><span class="nx">Model</span><span class="p">.</span><span class="nx">extend</span><span class="p">({</span>
    <span class="nx">defaults</span> <span class="o">:</span> <span class="p">{</span>
        <span class="nx">name</span> <span class="o">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="nx">roles</span> <span class="o">:</span> <span class="nx">Collection</span><span class="p">.</span><span class="nx">RefsTo</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">collection</span><span class="p">.</span><span class="nx">rolesCollection</span><span class="p">;</span> <span class="c1">// &lt;- collection of Roles is the direct member of Users.Collection</span>
        <span class="p">}),</span>
        <span class="nx">location</span> <span class="o">:</span> <span class="nx">Location</span><span class="p">.</span><span class="nx">From</span><span class="p">(</span> <span class="kd">function</span><span class="p">(){</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">collection</span><span class="p">.</span><span class="nx">locationsCollection</span><span class="p">;</span> <span class="c1">// &lt;- collection of Roles is the direct member of Users.Collection</span>
        <span class="p">})</span>
    <span class="p">}</span>
<span class="p">});</span>
</pre></div>

<p>Note, that 'change' events won't be bubbled from models in Collection.SubsetOf. Other collection's events will.</p>

<p>For Model.From attribute no model changes will be bubbled.</p>

<h3>
<a name="attribute-options" class="anchor" href="#attribute-options"><span class="octicon octicon-link"></span></a>Attribute options</h3>

<ul>
<li>type and value</li>
<li>override native property</li>
<li>override parse/toJSON</li>
</ul>

<p>Attribute options spec allow for a full control on the attribute options, including 'type' and 'value'. Attribute type specification is the special case of options spec, which, in its most general form, looks like this:</p>

<pre><code>NestedTypes.options({ ... })
</code></pre>

<p>The relation between short and long forms of attribute options spec is summarized in the table below:</p>

<table>
<thead>
<tr>
<th>Short form</th>
<th>Long form</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type</td>
<td>NestedTypes.options({ type : Type })</td>
</tr>
<tr>
<td>Type.options({ ... })</td>
<td>NestedTypes.options({ type : Type, ... })</td>
</tr>
<tr>
<td>NestedTypes.value( x )</td>
<td>NestedTypes.options({ value : x })</td>
</tr>
<tr>
<td>Type.value( x )</td>
<td>NestedTypes.options({ type : Type, value: x })</td>
</tr>
</tbody>
</table>

<p>Both long and short forms of attribute options are chainable. I.e. following constructs are possible:</p>

<pre><code>Type.value( x ).options({ ... }) // same as NestedTypes.options({ type : Type, value : x, ... })
NestedTypes.value( x ).options({ ... }) // = NestedTypes.options({ value : x, ... })
NestedTypes.options({ ... }).value( x ) // = NestedTypes.options({ value : x, ... })
...
</code></pre>

<p>Available options so far are:</p>

<table>
<thead>
<tr>
<th>Option</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>type : Ctor</td>
<td>attribute's type (constructor function)</td>
</tr>
<tr>
<td>value : x</td>
<td>attribute's default value</td>
</tr>
<tr>
<td>toJSON : false</td>
<td>attribute will not be serialized to JSON</td>
</tr>
<tr>
<td>toJSON : function( attrValue, attrName ) -&gt; JSON</td>
<td>serialize attribute to JSON with the given function</td>
</tr>
<tr>
<td>parse  : function( data ) -&gt; {attribute hash}</td>
<td>parse attribute with a given function</td>
</tr>
<tr>
<td>get : function() -&gt; value</td>
<td>override native property getter for the attribute</td>
</tr>
<tr>
<td>set : function( value ) -&gt; value</td>
<td>to override native property setter for the attribute</td>
</tr>
<tr>
<td>triggerWhenChanged : String</td>
<td>bubble 'change' event when given list of events are triggered by the attribute</td>
</tr>
<tr>
<td>triggerWhenChanged : false</td>
<td>don't bubble 'change' events from the the attribute</td>
</tr>
</tbody>
</table>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Backbone.nestedtypes maintained by <a href="https://github.com/Volicon">Volicon</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
