<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Backbone.nestedtypes : Backbone.js extension adding native properties for models, defaults&#39; type annotations, nested models and collections.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Backbone.nestedtypes</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/Volicon/backbone.nestedTypes">View on GitHub</a>

          <h1 id="project_title">Backbone.nestedtypes</h1>
          <h2 id="project_tagline">Backbone.js extension adding native properties for models, defaults&#39; type annotations, nested models and collections.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/Volicon/backbone.nestedTypes/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/Volicon/backbone.nestedTypes/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="important-version-0911-compatibility-note" class="anchor" href="#important-version-0911-compatibility-note" aria-hidden="true"><span class="octicon octicon-link"></span></a>IMPORTANT! Version 0.9.11 compatibility note</h1>

<p>There might be compatibility issues in you application when you upgrade to this release, so read this section carefully.</p>

<p>Nested.Attribute is deprecated. Use:</p>

<ul>
<li>Nested.options({ ... }) instead of Nested.Attribute({ ... })</li>
<li><p>Type.value( value ) instead of Nested.Attribute( Type, value )</p></li>
<li><p>New semantic for attribute's get and set hooks. Previously, attribute options 'set' and 'get' used to override native properties. Please, refer to "get hook" and "set hook" topics.</p></li>
<li>Model.from and Collection.subsefOf now started with lowercase letter, and will return null and [] when not resolved instead of dummy objects.</li>
</ul>

<p>Except of these issues, upgrade should go fine. If you will encounter any problems during upgrade which are not covered here, don't hesitate to report a bug.</p>

<h1>
<a id="backbonenestedtypes" class="anchor" href="#backbonenestedtypes" aria-hidden="true"><span class="octicon octicon-link"></span></a>backbone.nestedTypes</h1>

<p>NestedTypes is the type system for JavaScript, implemented on top of  Backbone. It solve common architectural problems of Backbone applications, providing simple yet powerful tools to deal with complex nested data structures. Brief feature list:</p>

<ul>
<li>Class and Integer types</li>
<li>
<em>Native properties</em> for Model attributes, Collection, and Class.</li>
<li>Inline Collection definition syntax for Models.</li>
<li>Model.defaults inheritance and deep copying.</li>
<li>Type declarations and automatic type casts for Model attributes.</li>
<li>Easy handling of Date attributes.</li>
<li>
<em>Nested models</em> and collections.</li>
<li>
<em>One-to-many</em> and <em>many-to-many</em> models relations.</li>
<li>'change' event bubbling for nested models and collections.</li>
<li>Attribute-level control for parse/toJSON and event bubbling.</li>
<li>Run-time type error detection and logging.</li>
</ul>

<h2>
<a id="how-it-feels-like" class="anchor" href="#how-it-feels-like" aria-hidden="true"><span class="octicon octicon-link"></span></a>How it feels like</h2>

<p>It feels much like statically typed programming language. Yet, it's vanilla JavaScript.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> User <span class="pl-k">=</span> Nested.Model.extend({
    urlRoot <span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>/api/users<span class="pl-pds">'</span></span>,

    attributes <span class="pl-k">:</span> {
        <span class="pl-c">// Primitive types</span>
        login    <span class="pl-k">:</span> <span class="pl-s3">String</span>, <span class="pl-c">// = ""</span>
        email    <span class="pl-k">:</span> <span class="pl-s3">String</span>.<span class="pl-sc">value</span>( <span class="pl-c1">null</span> ), <span class="pl-c">// = null</span>
        loginCount <span class="pl-k">:</span> <span class="pl-s3">Number</span>.<span class="pl-sc">options</span>({ toJSON <span class="pl-k">:</span> <span class="pl-c1">false</span> }) <span class="pl-c">// = 0, not serialized</span>
        active   <span class="pl-k">:</span> <span class="pl-s3">Boolean</span>.<span class="pl-sc">value</span>( <span class="pl-c1">true</span> ), <span class="pl-c">// = true</span>

        created  <span class="pl-k">:</span> <span class="pl-s3">Date</span>, <span class="pl-c">// = new Date()</span>

        settings <span class="pl-k">:</span> Settings, <span class="pl-c">// nested model</span>

        <span class="pl-c">// collection of models, received as an array of model ids</span>
        roles    <span class="pl-k">:</span> Role.Collection.SubsetOf( rolesCollection ),
        <span class="pl-c">// reference to model, received as model id.</span>
        office <span class="pl-k">:</span> Office.From( officeCollection )
    }
});

<span class="pl-s">var</span> collection <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">User.Collection</span>(); <span class="pl-c">// Collection is already there...</span>
collection.fetch().done( <span class="pl-st">function</span>(){
    <span class="pl-s">var</span> user <span class="pl-k">=</span> collection.first();
    <span class="pl-en">console</span><span class="pl-s3">.log</span>( user.<span class="pl-sc">name</span> ); <span class="pl-c">// native properties</span>
    <span class="pl-en">console</span><span class="pl-s3">.log</span>( user.office.<span class="pl-sc">name</span> );
    <span class="pl-en">console</span><span class="pl-s3">.log</span>( user.roles.first().<span class="pl-sc">name</span> );
});</pre></div>

<p>Types are being checked in run-time on assignment, but instead of throwing exceptions it tries to cast values to defined types. For example:</p>

<div class="highlight highlight-javascript"><pre>    user.login <span class="pl-k">=</span> <span class="pl-c1">1</span>;
    <span class="pl-en">console</span><span class="pl-s3">.assert</span>( user.login <span class="pl-k">===</span> <span class="pl-s1"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span> );

    user.active <span class="pl-k">=</span> <span class="pl-c1">undefined</span>;
    <span class="pl-en">console</span><span class="pl-s3">.assert</span>( user.active <span class="pl-k">===</span> <span class="pl-c1">false</span> );

    user.loginCount <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>hjkhjkhfjkhjkfd<span class="pl-pds">"</span></span>;
    <span class="pl-en">console</span><span class="pl-s3">.assert</span>( _.isNan( user.loginCount ) );

    user.settings <span class="pl-k">=</span> { timeZone <span class="pl-k">:</span> <span class="pl-c1">180</span> }; <span class="pl-c">// same as user.settings.set({ timeZone : 180 })</span>
    <span class="pl-en">console</span><span class="pl-s3">.assert</span>( user.settings <span class="pl-k">instanceof</span> Settings );</pre></div>

<h2>
<a id="requirements--installation" class="anchor" href="#requirements--installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements &amp; Installation</h2>

<p>All modern browsers and IE9+ are supported. To install, type</p>

<pre><code>bower install backbone.nested-types
</code></pre>

<p>or</p>

<pre><code>npm install backbone.nested-types
</code></pre>

<p>or just copy 'nestedtypes.js' file to desired location.</p>

<p>NestedTypes is compatible with node.js, CommonJS/AMD (e.g. RequireJS) module loaders, and could be included with plain script tag as well. To include it, use</p>

<pre><code>var NestedTypes = require( 'nestedtypes');
</code></pre>

<p>or</p>

<pre><code>require([ 'nestedtypes' ], function( NestedTypes ){
</code></pre>

<p>or</p>

<pre><code>&lt;script src="nestedtypes.js" type="text/javascript"&gt;&lt;/script&gt;
</code></pre>

<h1>
<a id="api-reference" class="anchor" href="#api-reference" aria-hidden="true"><span class="octicon octicon-link"></span></a>API Reference</h1>

<h2>
<a id="basic-features" class="anchor" href="#basic-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic features</h2>

<h3>
<a id="modeldefaults" class="anchor" href="#modeldefaults" aria-hidden="true"><span class="octicon octicon-link"></span></a>Model.defaults:</h3>

<ul>
<li>Models.attributes as an alternative to 'defaults'</li>
<li>Native properties are created for every entry.</li>
<li>Entries are inherited from the base Model.defaults/attributes.</li>
<li>JSON literals will be deep copied upon creation of model.</li>
<li>attributes <em>must</em> be declared in defaults/attributes.</li>
</ul>

<p>'defaults' spec may be a function or object, 'attributes' <em>must</em> be an object.</p>

<div class="highlight highlight-javascript"><pre>    <span class="pl-s">var</span> UserInfo <span class="pl-k">=</span> Nested.Model.extend({
        defaults <span class="pl-k">:</span> {
            name <span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>test<span class="pl-pds">'</span></span>,
        }
    });

    <span class="pl-s">var</span> DetailedUserInfo <span class="pl-k">=</span> UserInfo.extend({
        attributes <span class="pl-k">:</span> { <span class="pl-c">// &lt;- the same as 'defaults', use whatever you like</span>
            login <span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>,
            roles <span class="pl-k">:</span> [ <span class="pl-s1"><span class="pl-pds">'</span>user<span class="pl-pds">'</span></span> ]
        }
    });

    <span class="pl-s">var</span> user <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">DetailedUserInfo</span>();

    <span class="pl-c">// user.get( 'name' ) would be undefined in plain Backbone.</span>
    <span class="pl-en">console</span><span class="pl-s3">.assert</span>( user.<span class="pl-sc">name</span> <span class="pl-k">===</span> <span class="pl-s1"><span class="pl-pds">'</span>test<span class="pl-pds">'</span></span> ); <span class="pl-c">// you still can use 'get', but why...</span>
    user.<span class="pl-sc">name</span> <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">'</span>admin<span class="pl-pds">'</span></span>;

    <span class="pl-c">// In Backbone all models will share the same instance of [ 'user' ] array.</span>
    <span class="pl-c">// So, following line will create a bug. Not in NestedTypes.</span>
    user.roles.<span class="pl-s3">push</span>( <span class="pl-s1"><span class="pl-pds">'</span>admin<span class="pl-pds">'</span></span> );</pre></div>

<h3>
<a id="inline-collection-definition-modelcollection" class="anchor" href="#inline-collection-definition-modelcollection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Inline collection definition (Model.collection).</h3>

<p>By the way, our models from previous example has collections defined already.</p>

<div class="highlight highlight-javascript"><pre>    <span class="pl-s">var</span> users <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">UserInfo.Collection</span>();
    <span class="pl-s">var</span> detailedUsers <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">DetailedUserInfo.Collection</span>();</pre></div>

<p>Every model definition creates Collection type extending base Model.Collection.  Collection.model and Collection.url properties are taken from model. You could customize collection with a spec in Model.collection, which then will be passed to BaseModel.Collection.extend.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> DetailedUserInfo <span class="pl-k">=</span> UserInfo.extend({
    urlBase <span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>/api/detailed_user/<span class="pl-pds">'</span></span>,

    defaults <span class="pl-k">:</span> {
        login <span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>,
        roles <span class="pl-k">:</span> [ <span class="pl-s1"><span class="pl-pds">'</span>user<span class="pl-pds">'</span></span> ]
    },

    collection <span class="pl-k">:</span> {
        <span class="pl-en">initialize</span> : <span class="pl-st">function</span>(){
            <span class="pl-v">this</span>.fetch();
        }
    }
});

<span class="pl-c">/*</span>
<span class="pl-c">    DetailedUserInfo.Collection = UserInfo.Collection.extend({</span>
<span class="pl-c">        url : '/api/detailed_user/',</span>
<span class="pl-c">        model : DetailedUserInfo,</span>
<span class="pl-c"></span>
<span class="pl-c">        initialize: function(){</span>
<span class="pl-c">            this.fetch();</span>
<span class="pl-c">        }</span>
<span class="pl-c">    });</span>
<span class="pl-c">*/</span></pre></div>

<h3>
<a id="class-type-which-can-be-extended-and-can-throwlisten-to-events" class="anchor" href="#class-type-which-can-be-extended-and-can-throwlisten-to-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>Class type, which can be extended and can throw/listen to events.</h3>

<div class="highlight highlight-javascript"><pre>    <span class="pl-s">var</span> A <span class="pl-k">=</span> Nested.Class.extend({
        a <span class="pl-k">:</span> <span class="pl-c1">1</span>,

        <span class="pl-en">initialize</span> : <span class="pl-st">function</span>( <span class="pl-vpf">options</span> ){
            <span class="pl-v">this</span>.listenTo( options.other, <span class="pl-s1"><span class="pl-pds">'</span>event<span class="pl-pds">'</span></span>, doSomething )
        },

        <span class="pl-en">doSomething</span> : <span class="pl-st">function</span>(){
            <span class="pl-v">this</span>.trigger( <span class="pl-s1"><span class="pl-pds">'</span>something<span class="pl-pds">'</span></span> );
        }
    });

    <span class="pl-s">var</span> B <span class="pl-k">=</span> A.extend({
        b <span class="pl-k">:</span> <span class="pl-c1">2</span>,

        <span class="pl-en">initialize</span> : <span class="pl-st">function</span>( <span class="pl-vpf">options</span> ){
            A.<span class="pl-sc">prototype</span>.initialize.<span class="pl-s3">apply</span>( <span class="pl-v">this</span>, arguments );
            <span class="pl-v">this</span>.listenTo( options.another, <span class="pl-s1"><span class="pl-pds">'</span>event<span class="pl-pds">'</span></span>, doSomething )
        },
    });

    <span class="pl-s">var</span> b <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">B</span>( options );</pre></div>

<h3>
<a id="explicit-native-properties-definition-model-class-collection" class="anchor" href="#explicit-native-properties-definition-model-class-collection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Explicit native properties definition (Model, Class, Collection).</h3>

<p>Native properties are generated for model attributes, however, they also can be defined explicitly for Model, Class, Collection with 'properties' specification.</p>

<p>For Model, explicit property will override generated one, and "properties : false" disable defaults native properties generation.</p>

<div class="highlight highlight-javascript"><pre>    <span class="pl-s">var</span> A <span class="pl-k">=</span> Nested.Model.extend({
        defaults <span class="pl-k">:</span> {
            a <span class="pl-k">:</span> <span class="pl-c1">1</span>,
            b <span class="pl-k">:</span> <span class="pl-c1">2</span>
        },

        properties <span class="pl-k">:</span> {
            <span class="pl-en">c</span> : <span class="pl-st">function</span>(){
                <span class="pl-k">return</span> <span class="pl-v">this</span>.a <span class="pl-k">+</span> <span class="pl-v">this</span>.b;
            },

            ax2 <span class="pl-k">:</span> {
                <span class="pl-en">get</span> : <span class="pl-st">function</span>(){
                    <span class="pl-k">return</span> <span class="pl-v">this</span>.a <span class="pl-k">*</span> <span class="pl-c1">2</span>;
                },

                <span class="pl-en">set</span> : <span class="pl-st">function</span>( <span class="pl-vpf">value</span> ){
                    <span class="pl-v">this</span>.a <span class="pl-k">=</span> value / <span class="pl-c1">2</span>;
                    <span class="pl-k">return</span> value;
                }
            }
        }
    });

    <span class="pl-s">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">A</span>();
    <span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.c <span class="pl-k">===</span> <span class="pl-c1">3</span> );

    a.ax2 <span class="pl-k">=</span> <span class="pl-c1">4</span>;
    <span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.c <span class="pl-k">===</span> <span class="pl-c1">2</span> );</pre></div>

<h3>
<a id="run-time-errors" class="anchor" href="#run-time-errors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run-time errors</h3>

<p>NestedTypes detect three error types in the runtime, which will be logged to console using console.error.</p>

<pre><code>[Type error](Model.extend) Property "name" conflicts with base class members.
</code></pre>

<p>It's forbidden for native properties to override members of the base Model. Since native properties are generated for Model.defaults elements, its also forbidden to have attribute names which are the same as members of the base Model.</p>

<pre><code>[Type Error](Model.set) Attribute hash is not an object: ...
</code></pre>

<p>First argument of Model.set must be either string, or literal object representing attribute hash.</p>

<pre><code>[Type Error](Model.set) Attribute "name" has no default value.
</code></pre>

<p>Attempt to set attribute which is not declared in defaults.</p>

<h2>
<a id="modeldefaults-type-specs" class="anchor" href="#modeldefaults-type-specs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Model.defaults Type Specs</h2>

<h3>
<a id="basic-type-annotation-syntax-and-rules" class="anchor" href="#basic-type-annotation-syntax-and-rules" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic type annotation syntax and rules</h3>

<p>IMPORTANT! Model.defaults must be an object to use attribute type annotations features described here.
defaults function body is supported for backward compatibility with backbone only, in order to simplify transition.</p>

<p>Type specs can be optionally used instead of init values in Model.defaults. They looks like this:</p>

<pre><code>name : Constructor
</code></pre>

<p>or</p>

<pre><code>name : Constructor.value( x )
</code></pre>

<p>where Constructor is JS constructor function, and x is its default value.</p>

<p>When default value is not specified, typed attribute is initialized invoking 'new Constructor()'.</p>

<p>As a general rule, when typed attribute is assigned with the value...</p>

<ul>
<li>which is null, attribute will be set to null.</li>
<li>which is an instance of Constructor, attribute's value will be replaced.</li>
<li>in other case, NestedTypes will try to convert value to the Constructor type, typically invoking "new Constructor( value )". This type conversion algorithm may be overriden for some selected types.</li>
</ul>

<p>When receiving data from server, type cast logic is used to parse JSON responce; typically you don't need to override Model.parse.</p>

<p>When sending data to the server, Constructor.toJSON will be invoked to produce JSON for typed attributes, so you don't need to override Model.toJSON for that.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> A <span class="pl-k">=</span> Nested.Model.extend({
    defaults <span class="pl-k">:</span> {
        obj1 <span class="pl-k">:</span> Ctor, <span class="pl-c">// = new Ctor()</span>
        obj2 <span class="pl-k">:</span> Ctor.<span class="pl-sc">value</span>( <span class="pl-c1">null</span> ), <span class="pl-c">// = null</span>
        obj3 <span class="pl-k">:</span> Ctor.<span class="pl-sc">value</span>( something ), <span class="pl-c">// = new Ctor( something )</span>
    }
});

<span class="pl-s">var</span> a <span class="pl-k">=</span> A();

a.obj2 <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>dsds<span class="pl-pds">"</span></span>; <span class="pl-c">// a.obj2 = new Ctor( "dsds" );</span>

<span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.obj2 <span class="pl-k">instanceof</span> Ctor );</pre></div>

<h3>
<a id="primitive-types-boolean-number-string-integer" class="anchor" href="#primitive-types-boolean-number-string-integer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Primitive types (Boolean, Number, String, Integer)</h3>

<p>Primitive types are special in a sense that <em>they are inferred from their values</em>, so they are always typed. In most cases special type annotation syntax is not really required.</p>

<p>It means that if attribute has default value of 5 <em>then it's guaranteed to be Number or null</em> (it will be casted to Number on assignments). This is quite different from original Backbone's behaviour which you might expect, and it makes models safer. For polimorphic attributes holding different types you can disable type inference using 'Nested.value'.</p>

<p>IMPORTANT! Although it's not possible to use type annotations in Model.defaults function body, primitive types will be inferred from their values in this case. So beware.</p>

<p>NestedTypes adds global Integer type, to be used in type annotations. It behaves the same as Number, but convert values to integer on attribute assignment using Math.round. Integer type is not being inferred from the values, and needs to be specified explicitly.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> A <span class="pl-k">=</span> Nested.Model.extend({
    defaults <span class="pl-k">:</span> {
        <span class="pl-c">// Original backbone behaviour - no type, value is 3232</span>
        untyped <span class="pl-k">:</span> Nested.<span class="pl-sc">value</span>( <span class="pl-c1">3232</span> )

        <span class="pl-c">// defaults with primitive types are always 'typed'</span>
        number  <span class="pl-k">:</span> <span class="pl-c1">5</span>,           <span class="pl-c">// same as Number.value( 5 )</span>
        integer <span class="pl-k">:</span> Integer.<span class="pl-sc">value</span>( <span class="pl-c1">6</span> ),
        string  <span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>something<span class="pl-pds">'</span></span>, <span class="pl-c">// same as String.value( 'something' )</span>
        string1 <span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>,          <span class="pl-c">// same as String</span>
        boolean <span class="pl-k">:</span> <span class="pl-c1">true</span>,        <span class="pl-c">// same as Boolean.value( true )</span>

        initWithNull  <span class="pl-k">:</span> <span class="pl-s3">String</span>.<span class="pl-sc">value</span>( <span class="pl-c1">null</span> ), <span class="pl-c">// Type is String, default value is null</span>
    }
});

<span class="pl-s">var</span> a <span class="pl-k">=</span> A();

a.boolean <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>;
<span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.boolean <span class="pl-k">===</span> <span class="pl-c1">true</span> );

a.number <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>5<span class="pl-pds">"</span></span>;
<span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.number <span class="pl-k">===</span> <span class="pl-c1">5</span> );

a.number <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">"</span>hjhjfd<span class="pl-pds">"</span></span>;
<span class="pl-en">console</span><span class="pl-s3">.assert</span>( _.<span class="pl-s3">isNaN</span>( a.number ) );

a.integer <span class="pl-k">=</span> <span class="pl-c1">1.5423</span>;
<span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.integer <span class="pl-k">===</span> <span class="pl-c1">2</span> );

a.string <span class="pl-k">=</span> <span class="pl-c1">5</span>;
<span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.string <span class="pl-k">===</span> <span class="pl-s1"><span class="pl-pds">"</span>5<span class="pl-pds">"</span></span> );

a.boolean <span class="pl-k">=</span> <span class="pl-c1">0</span>;
<span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.boolean <span class="pl-k">===</span> <span class="pl-c1">false</span> );</pre></div>

<h3>
<a id="date-type" class="anchor" href="#date-type" aria-hidden="true"><span class="octicon octicon-link"></span></a>Date type</h3>

<ul>
<li>Automatic parsing of common JSON date representations.</li>
<li>Automatically serialized to ISO string (don't need to override toJSON)</li>
</ul>

<p>Date attributes free you from overriding Model.parse or Model.toJSON when you want to transfer dates between server and client.</p>

<p>Strings and numbers will be converted to date with Date constructor. NestedTypes contains additional logic to implement cross-browser ISO date parsing and handling of MS date format.</p>

<p>On serialization, Date.toJSON will be invoked for date attribute, producing UTC-0 ISO date string representation.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> A <span class="pl-k">=</span> Nested.Model.extend({
    defaults <span class="pl-k">:</span> {
        created <span class="pl-k">:</span> <span class="pl-s3">Date</span>, <span class="pl-c">// = new Date()</span>
        updated <span class="pl-k">:</span> <span class="pl-s3">Date</span>.<span class="pl-sc">value</span>( <span class="pl-c1">null</span> ), <span class="pl-c">// = null</span>
        a <span class="pl-k">:</span> <span class="pl-s3">Date</span>.<span class="pl-sc">value</span>( <span class="pl-c1">327943789</span> ), <span class="pl-c">//  = new Date( 327943789 )</span>
        b <span class="pl-k">:</span> <span class="pl-s3">Date</span>.<span class="pl-sc">value</span>( <span class="pl-s1"><span class="pl-pds">"</span>2012-12-12 12:12<span class="pl-pds">"</span></span> ) <span class="pl-c">//  = new Date( "2012-12-12 12:12" )</span>
    }
});

<span class="pl-s">var</span> a <span class="pl-k">=</span> A();

a.updated <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">'</span>2012-12-12 12:12<span class="pl-pds">'</span></span>;
<span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.updated <span class="pl-k">instanceof</span> <span class="pl-s3">Date</span> );

a.updated <span class="pl-k">=</span> <span class="pl-s1"><span class="pl-pds">'</span>/Date(32323232323)/<span class="pl-pds">'</span></span>;
<span class="pl-en">console</span><span class="pl-s3">.assert</span>( a.updated <span class="pl-k">instanceof</span> <span class="pl-s3">Date</span> );</pre></div>

<h3>
<a id="nested-models-and-collections" class="anchor" href="#nested-models-and-collections" aria-hidden="true"><span class="octicon octicon-link"></span></a>Nested Models and Collections</h3>

<ul>
<li>automatic parsing and serialization</li>
<li>'deep updates' and 'deep clone'</li>
<li>'change' event bubbling</li>
</ul>

<p>To define nested model or collection, just annotate attributes with Model or Collection type.</p>

<p>Note, that Backbone's .clone() method will create shallow copy of the root model, while Model.deepClone() and Collection.deepClone() will clone model and collection with all subitems.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> User <span class="pl-k">=</span> Nested.Model.extend({
    defaults <span class="pl-k">:</span> {
        name        <span class="pl-k">:</span> <span class="pl-s3">String</span>,
        created     <span class="pl-k">:</span> <span class="pl-s3">Date</span>,
        group       <span class="pl-k">:</span> GroupModel,
        permissions <span class="pl-k">:</span> PermissionCollection
    }
});

<span class="pl-s">var</span> a <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">User</span>(),
    b <span class="pl-k">=</span> a.deepClone();</pre></div>

<p>Model/Collection type cast behavior depends on attribute value before assignment:</p>

<ul>
<li>If attribute value is null, Model/Collection constructor will be invoked as for usual types.</li>
<li>If attribute already holds model or collection, <em>deep update</em> will be performed instead.</li>
</ul>

<p>"Deep update" means that model/collection object itself will remain in place, and 'set' method will be used to perform an update.</p>

<p>I.e. this code:</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> user <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">User</span>();
user.group <span class="pl-k">=</span> {
    name<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">"</span>Admin<span class="pl-pds">"</span></span>
};

user.permissions <span class="pl-k">=</span> [{ id<span class="pl-k">:</span> <span class="pl-c1">5</span>, type<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>full<span class="pl-pds">'</span></span> }];</pre></div>

<p>is equivalent of:</p>

<div class="highlight highlight-javascript"><pre>user.group.set({
   name<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">"</span>Admin<span class="pl-pds">"</span></span>
};

user.permissions.set( [{ id<span class="pl-k">:</span> <span class="pl-c1">5</span>, type<span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>full<span class="pl-pds">'</span></span> }] );</pre></div>

<p>This mechanics of 'set' allows you to work with JSON from in case of deeply nested models and collections without the need to override 'parse'. This code (considering that nested attributes defined as models):</p>

<div class="highlight highlight-javascript"><pre>user.group <span class="pl-k">=</span> {
    nestedModel <span class="pl-k">:</span> {
        deeplyNestedModel <span class="pl-k">:</span> {
            attr <span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>value<span class="pl-pds">'</span></span>
        },

        attr <span class="pl-k">:</span> <span class="pl-c1">5</span>
    }
};</pre></div>

<p>is almost equivalent of:</p>

<div class="highlight highlight-javascript"><pre>user.group.nestedModel.deeplyNestedModel.set( <span class="pl-s1"><span class="pl-pds">'</span>attr<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>value<span class="pl-pds">'</span></span> );
user.group.nestedModel.set( <span class="pl-s1"><span class="pl-pds">'</span>attr<span class="pl-pds">'</span></span>, <span class="pl-s1"><span class="pl-pds">'</span>value<span class="pl-pds">'</span></span> );</pre></div>

<p>but it will fire just single <code>change</code> event.</p>

<p>Change events will be bubbled from nested models and collections.</p>

<ul>
<li>
<code>change</code> and <code>change:attribute</code> events for any changes in nested models and collections. Multiple <code>change</code> events from submodels during bulk updates are carefully joined together, which make it suitable to subscribe View.render to the top model's <code>change</code>.</li>
<li>
<code>replace:attribute</code> event when model or collection is replaced with new object. You might need it to subscribe for events from submodels.</li>
<li>It's possible to control event bubbling for every attribute. You can completely disable it, or override the list of events which would be counted as change:</li>
</ul>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> M <span class="pl-k">=</span> Nested.Model.extend({
    defaults<span class="pl-k">:</span> {
        bubbleChanges <span class="pl-k">:</span> ModelOrCollection,

        dontBubble <span class="pl-k">:</span> ModelOrCollection.<span class="pl-sc">options</span>({ triggerWhanChanged <span class="pl-k">:</span> <span class="pl-c1">false</span> })
        }),

        bubbleCustomEvents <span class="pl-k">:</span> ModelOrCollection.<span class="pl-sc">options</span>({
            triggerWhanChanged <span class="pl-k">:</span> <span class="pl-s1"><span class="pl-pds">'</span>event1 event2 whatever<span class="pl-pds">'</span></span>
        }),
    }
});</pre></div>

<h3>
<a id="attribute-options" class="anchor" href="#attribute-options" aria-hidden="true"><span class="octicon octicon-link"></span></a>Attribute options</h3>

<ul>
<li>type and value</li>
<li>override native property</li>
<li>override parse/toJSON</li>
</ul>

<p>Attribute options spec allow for a full control on the attribute options, including 'type' and 'value'. Attribute type specification is the special case of options spec, which, in its most general form, looks like this:</p>

<pre><code>Nested.options({ ... })
</code></pre>

<p>The relation between short and long forms of attribute options spec is summarized in the table below:</p>

<table>
<thead>
<tr>
<th>Short form</th>
<th>Long form</th>
</tr>
</thead>
<tbody>
<tr>
<td>Type</td>
<td>Nested.options({ type : Type })</td>
</tr>
<tr>
<td>Type.options({ ... })</td>
<td>Nested.options({ type : Type, ... })</td>
</tr>
<tr>
<td>Nested.value( x )</td>
<td>Nested.options({ value : x })</td>
</tr>
<tr>
<td>Type.value( x )</td>
<td>Nested.options({ type : Type, value: x })</td>
</tr>
</tbody>
</table>

<p>Both long and short forms of attribute options are chainable. I.e. following constructs are possible:</p>

<pre><code>Type.value( x ).options({ ... }) // same as Nested.options({ type : Type, value : x, ... })
Nested.value( x ).options({ ... }) // = Nested.options({ value : x, ... })
Nested.options({ ... }).value( x ) // = Nested.options({ value : x, ... })
...
</code></pre>

<p>Available options so far are:</p>

<h4>
<a id="type" class="anchor" href="#type" aria-hidden="true"><span class="octicon octicon-link"></span></a>type</h4>

<pre><code>type : Ctor
</code></pre>

<p>Attribute's type (constructor function). When no type is provided, attribute behaves as regular backbone attribute.</p>

<h4>
<a id="value" class="anchor" href="#value" aria-hidden="true"><span class="octicon octicon-link"></span></a>value</h4>

<pre><code>value : x
</code></pre>

<p>Attribute's default value. When type is specified, value will be casted to this type on construction.</p>

<h4>
<a id="tojson" class="anchor" href="#tojson" aria-hidden="true"><span class="octicon octicon-link"></span></a>toJSON</h4>

<pre><code>toJSON : function( attrValue, attrName ){ return attrValue.toJSON(); }
or
toJSON : false
</code></pre>

<p>When attribute will be serialized as a part of model, given function will be used <em>instead</em> of attribute's toJSON.
Function will be executed in the context of the model.</p>

<p>Specifying 'false' will prevent attribute form serialization.</p>

<h4>
<a id="parse" class="anchor" href="#parse" aria-hidden="true"><span class="octicon octicon-link"></span></a>parse</h4>

<pre><code>parse  : function( data ){ return data; }

</code></pre>

<p>When attribute is parsed as a part of the model, given function will be called <em>before</em> calling the attribute's parse.</p>

<h4>
<a id="get-hook" class="anchor" href="#get-hook" aria-hidden="true"><span class="octicon octicon-link"></span></a>get hook</h4>

<pre><code>get : function( value ){ return value; }
</code></pre>

<p>Called on Model.get in the context of the model, allowing you to modify returned value.</p>

<h4>
<a id="set-hook" class="anchor" href="#set-hook" aria-hidden="true"><span class="octicon octicon-link"></span></a>set hook</h4>

<pre><code>set : function( value, options ){ return value; }
</code></pre>

<p>Called on Model.set in the context of the model, allowing you to modify value before set ot cancel setting of the attribute, returning 'undefined'.</p>

<p>set hook is executed on every attribute change, <em>after</em> type cast. So, it's guaranteed that value will be of the correct type.</p>

<p>For nested models and collections it will be called only in case when model/collection
 instance will be replaced, which makes it a perfect place to handle custom events subscriptions.</p>

<h4>
<a id="property" class="anchor" href="#property" aria-hidden="true"><span class="octicon octicon-link"></span></a>property</h4>

<pre><code>property : function( name ){
    return {
        get : function(){
            return this.attribute[ name ];
        },

        set: function( value ){
            this.set( name, value );
            return value;
        }
    }
}
</code></pre>

<p>or</p>

<pre><code>property : false
</code></pre>

<p>This option is used to override attribute's native property. 'false' option will disable native property generation for this attribute.</p>

<p>It's low level, so use it with extreme care.</p>

<h4>
<a id="triggerwhenchanged" class="anchor" href="#triggerwhenchanged" aria-hidden="true"><span class="octicon octicon-link"></span></a>triggerWhenChanged</h4>

<pre><code>triggerWhenChanged : String
or
triggerWhenChanged : false
</code></pre>

<p>trigger 'change' event on the model when given list of events are triggered by the attribute.
Specify 'false' to turn off event bubbling.</p>

<h2>
<a id="one-to-many-and-many-to-many-model-relationships" class="anchor" href="#one-to-many-and-many-to-many-model-relationships" aria-hidden="true"><span class="octicon octicon-link"></span></a>One-to-many and many-to-many model relationships</h2>

<p>Sometimes when you have one-to-many and many-to-many relationships between Models, it is suitable to transfer such a relationships from server as arrays of model ids. NestedTypes gives you special attribute data types for this situation.</p>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> User <span class="pl-k">=</span> Nested.Model.extend({
    defaults <span class="pl-k">:</span> {
        name <span class="pl-k">:</span> <span class="pl-s3">String</span>,
        roles <span class="pl-k">:</span> RolesCollection.subsetOf( roles ) <span class="pl-c">// &lt;- serialized as array of model ids</span>
        location <span class="pl-k">:</span> <span class="pl-s3">Location</span>.from( locations ) <span class="pl-c">// &lt;- serialized as model id</span>
    }
});

<span class="pl-s">var</span> user <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">User</span>({ id<span class="pl-k">:</span> <span class="pl-c1">0</span> });
user.fetch(); <span class="pl-c">// &lt;- you'll receive from server "{ id: 0, name : 'john', roles : [ 1, 2, 3 ] }"</span>
...
<span class="pl-c">// however, user.roles behaves like normal collection of Roles.</span>
assert( user.roles <span class="pl-k">instanceof</span> Collection );
assert( user.roles.first() <span class="pl-k">instanceof</span> Role );</pre></div>

<p>Collection.subsetOf is a collection of models taken from existing collection. On first access of attribute of this type, it will resolve ids to real models from the given master collection.</p>

<p>If master collection is empty and thus references cannot be resolved, it will defer id resolution and just return empty collection or null. If master collection is not empty, it will filter out ids of non-existent models.</p>

<p>Master collection reference may be:</p>

<ul>
<li>direct reference to collection object</li>
<li>string, designating reference to the current model's member relative to 'this'.</li>
<li>function, which returns reference to collection and executed in the context of the current model.</li>
</ul>

<div class="highlight highlight-javascript"><pre><span class="pl-s">var</span> User <span class="pl-k">=</span> Nested.Model.extend({
    defaults <span class="pl-k">:</span> {
        name <span class="pl-k">:</span> <span class="pl-s3">String</span>,
        roles <span class="pl-k">:</span> Collection.subsetOf( <span class="pl-s1"><span class="pl-pds">'</span>collection.roles<span class="pl-pds">'</span></span> ); <span class="pl-c">// this.collection.roles</span>
        location <span class="pl-k">:</span> <span class="pl-s3">Location</span>.from( <span class="pl-st">function</span>(){ <span class="pl-k">return</span> <span class="pl-v">this</span>.collection.locations; }); <span class="pl-c">// this.collection.locations</span>
    }
});</pre></div>

<p>There's a global store for the collections, which might be useful in case of bi-directional relationships. It's available as a member of Model (this.store), and globally as Nested.store.</p>

<p>Store needs to be initialized with a hash of collections and models type specs. It can be initialized several times. On first access to every member of the store, it will fetch data from the server automatically. You need to take care of update events.</p>

<div class="highlight highlight-javascript"><pre>Nested.store <span class="pl-k">=</span> {
    roles <span class="pl-k">:</span> Role.Collection,
    locations <span class="pl-k">:</span> Locations.Collection
}

<span class="pl-s">var</span> User <span class="pl-k">=</span> Nested.Model.extend({
    defaults <span class="pl-k">:</span> {
        name <span class="pl-k">:</span> <span class="pl-s3">String</span>,
        roles <span class="pl-k">:</span> Collection.subsetOf( <span class="pl-s1"><span class="pl-pds">'</span>store.roles<span class="pl-pds">'</span></span> ); <span class="pl-c">// this.store.roles</span>
        location <span class="pl-k">:</span> <span class="pl-s3">Location</span>.from( <span class="pl-st">function</span>(){ <span class="pl-k">return</span> <span class="pl-v">this</span>.store.locations; }); <span class="pl-c">// this.store.locations</span>
    }
});</pre></div>

<p>Store behaves as regular model, but provide some additional methods:</p>

<ul>
<li>fetch() will update all store members, which are loaded.</li>
<li>fetch( 'name1', 'name2', ... ) will fetch listed members and return promise.</li>
<li>clear() will clear all collections in store and return store to allow chained calls.</li>
<li>clear( 'name1', 'name2', ... ) will clear listed members.</li>
</ul>

<p>Note, that 'change' events won't be bubbled from models in Collection.subsetOf. Other collection's events will.</p>

<p>For Model.from attribute no model changes will be bubbled.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Backbone.nestedtypes maintained by <a href="https://github.com/Volicon">Volicon</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
