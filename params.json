{"name":"Backbone.nestedtypes","tagline":"Backbone.js extension adding native properties for models, defaults' type annotations, nested models and collections.","body":"IMPORTANT! Version 0.9.11 compatibility note\r\n==================\r\nThere might be compatibility issues in you application when you upgrade to this release, so read this section carefully.\r\n\r\nNested.Attribute is deprecated. Use:\r\n- Nested.options({ ... }) instead of Nested.Attribute({ ... })\r\n- Type.value( value ) instead of Nested.Attribute( Type, value )\r\n\r\n- New semantic for attribute's get and set hooks. Previously, attribute options 'set' and 'get' used to override native properties. Please, refer to \"get hook\" and \"set hook\" topics.\r\n- Model.from and Collection.subsefOf now started with lowercase letter, and will return null and [] when not resolved instead of dummy objects.\r\n\r\nExcept of these issues, upgrade should go fine. If you will encounter any problems during upgrade which are not covered here, don't hesitate to report a bug.\r\n\r\nbackbone.nestedTypes\r\n====================\r\n\r\nNestedTypes is the type system for JavaScript, implemented on top of  Backbone. It solve common architectural problems of Backbone applications, providing simple yet powerful tools to deal with complex nested data structures. Brief feature list:\r\n\r\n- Class and Integer types\r\n- *Native properties* for Model attributes, Collection, and Class.\r\n- Inline Collection definition syntax for Models.\r\n- Model.defaults inheritance and deep copying.\r\n- Type declarations and automatic type casts for Model attributes.\r\n- Easy handling of Date attributes.\r\n- *Nested models* and collections.\r\n- *One-to-many* and *many-to-many* models relations.\r\n- 'change' event bubbling for nested models and collections.\r\n- Attribute-level control for parse/toJSON and event bubbling.\r\n- Run-time type error detection and logging.\r\n\r\nHow it feels like\r\n-----------------\r\n\r\nIt feels much like statically typed programming language. Yet, it's vanilla JavaScript.\r\n\r\n```javascript\r\nvar User = Nested.Model.extend({\r\n    urlRoot : '/api/users',\r\n\r\n    attributes : {\r\n        // Primitive types\r\n        login    : String, // = \"\"\r\n        email    : String.value( null ), // = null\r\n        loginCount : Number.options({ toJSON : false }) // = 0, not serialized\r\n        active   : Boolean.value( true ), // = true\r\n\r\n        created  : Date, // = new Date()\r\n\r\n        settings : Settings, // nested model\r\n\r\n        // collection of models, received as an array of model ids\r\n        roles    : Role.Collection.SubsetOf( rolesCollection ),\r\n        // reference to model, received as model id.\r\n        office : Office.From( officeCollection )\r\n    }\r\n});\r\n\r\nvar collection = new User.Collection(); // Collection is already there...\r\ncollection.fetch().done( function(){\r\n    var user = collection.first();\r\n    console.log( user.name ); // native properties\r\n    console.log( user.office.name );\r\n    console.log( user.roles.first().name );\r\n});\r\n```\r\n\r\nTypes are being checked in run-time on assignment, but instead of throwing exceptions it tries to cast values to defined types. For example:\r\n\r\n```javascript\r\n    user.login = 1;\r\n    console.assert( user.login === \"1\" );\r\n\r\n    user.active = undefined;\r\n    console.assert( user.active === false );\r\n\r\n    user.loginCount = \"hjkhjkhfjkhjkfd\";\r\n    console.assert( _.isNan( user.loginCount ) );\r\n\r\n    user.settings = { timeZone : 180 }; // same as user.settings.set({ timeZone : 180 })\r\n    console.assert( user.settings instanceof Settings );\r\n```\r\n\r\nRequirements & Installation\r\n---------------------------\r\n\r\nAll modern browsers and IE9+ are supported. To install, type\r\n\r\n    bower install backbone.nested-types\r\n\r\nor\r\n\r\n    npm install backbone.nested-types\r\n\r\nor just copy 'nestedtypes.js' file to desired location.\r\n\r\nNestedTypes is compatible with node.js, CommonJS/AMD (e.g. RequireJS) module loaders, and could be included with plain script tag as well. To include it, use\r\n\r\n    var NestedTypes = require( 'nestedtypes');\r\n\r\nor\r\n\r\n    require([ 'nestedtypes' ], function( NestedTypes ){\r\n\r\nor\r\n\r\n    <script src=\"nestedtypes.js\" type=\"text/javascript\"></script>\r\n\r\n\r\n# API Reference\r\n## Basic features\r\n### Model.defaults:\r\n- Models.attributes as an alternative to 'defaults'\r\n- Native properties are created for every entry.\r\n- Entries are inherited from the base Model.defaults/attributes.\r\n- JSON literals will be deep copied upon creation of model.\r\n- attributes *must* be declared in defaults/attributes.\r\n\r\n'defaults' spec may be a function or object, 'attributes' *must* be an object.\r\n\r\n```javascript\r\n    var UserInfo = Nested.Model.extend({\r\n        defaults : {\r\n            name : 'test',\r\n        }\r\n    });\r\n\r\n    var DetailedUserInfo = UserInfo.extend({\r\n        attributes : { // <- the same as 'defaults', use whatever you like\r\n            login : '',\r\n            roles : [ 'user' ]\r\n        }\r\n    });\r\n\r\n    var user = new DetailedUserInfo();\r\n\r\n    // user.get( 'name' ) would be undefined in plain Backbone.\r\n    console.assert( user.name === 'test' ); // you still can use 'get', but why...\r\n    user.name = 'admin';\r\n\r\n    // In Backbone all models will share the same instance of [ 'user' ] array.\r\n    // So, following line will create a bug. Not in NestedTypes.\r\n    user.roles.push( 'admin' );\r\n```\r\n\r\n### Inline collection definition (Model.collection).\r\n\r\nBy the way, our models from previous example has collections defined already.\r\n```javascript\r\n    var users = new UserInfo.Collection();\r\n    var detailedUsers = new DetailedUserInfo.Collection();\r\n```\r\n\r\nEvery model definition creates Collection type extending base Model.Collection.  Collection.model and Collection.url properties are taken from model. You could customize collection with a spec in Model.collection, which then will be passed to BaseModel.Collection.extend.\r\n\r\n```javascript\r\nvar DetailedUserInfo = UserInfo.extend({\r\n    urlBase : '/api/detailed_user/',\r\n\r\n    defaults : {\r\n        login : '',\r\n        roles : [ 'user' ]\r\n    },\r\n\r\n    collection : {\r\n        initialize : function(){\r\n            this.fetch();\r\n        }\r\n    }\r\n});\r\n\r\n/*\r\n    DetailedUserInfo.Collection = UserInfo.Collection.extend({\r\n        url : '/api/detailed_user/',\r\n        model : DetailedUserInfo,\r\n\r\n        initialize: function(){\r\n            this.fetch();\r\n        }\r\n    });\r\n*/\r\n```\r\n\r\n### Class type, which can be extended and can throw/listen to events.\r\n\r\n```javascript\r\n    var A = Nested.Class.extend({\r\n        a : 1,\r\n\r\n        initialize : function( options ){\r\n            this.listenTo( options.other, 'event', doSomething )\r\n        },\r\n\r\n        doSomething : function(){\r\n            this.trigger( 'something' );\r\n        }\r\n    });\r\n\r\n    var B = A.extend({\r\n        b : 2,\r\n\r\n        initialize : function( options ){\r\n            A.prototype.initialize.apply( this, arguments );\r\n            this.listenTo( options.another, 'event', doSomething )\r\n        },\r\n    });\r\n\r\n    var b = new B( options );\r\n```\r\n\r\n### Explicit native properties definition (Model, Class, Collection).\r\n\r\nNative properties are generated for model attributes, however, they also can be defined explicitly for Model, Class, Collection with 'properties' specification.\r\n\r\nFor Model, explicit property will override generated one, and \"properties : false\" disable defaults native properties generation.\r\n\r\n```javascript\r\n    var A = Nested.Model.extend({\r\n        defaults : {\r\n            a : 1,\r\n            b : 2\r\n        },\r\n\r\n        properties : {\r\n            c : function(){\r\n                return this.a + this.b;\r\n            },\r\n\r\n            ax2 : {\r\n                get : function(){\r\n                    return this.a * 2;\r\n                },\r\n\r\n                set : function( value ){\r\n                    this.a = value / 2;\r\n                    return value;\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    var a = new A();\r\n    console.assert( a.c === 3 );\r\n\r\n    a.ax2 = 4;\r\n    console.assert( a.c === 2 );\r\n```\r\n\r\n### Run-time errors\r\n\r\nNestedTypes detect three error types in the runtime, which will be logged to console using console.error.\r\n\r\n```\r\n[Type error](Model.extend) Property \"name\" conflicts with base class members.\r\n```\r\nIt's forbidden for native properties to override members of the base Model. Since native properties are generated for Model.defaults elements, its also forbidden to have attribute names which are the same as members of the base Model.\r\n\r\n```\r\n[Type Error](Model.set) Attribute hash is not an object: ...\r\n```\r\nFirst argument of Model.set must be either string, or literal object representing attribute hash.\r\n\r\n```\r\n[Type Error](Model.set) Attribute \"name\" has no default value.\r\n```\r\nAttempt to set attribute which is not declared in defaults.\r\n\r\n\r\n## Model.defaults Type Specs\r\n### Basic type annotation syntax and rules\r\n\r\nIMPORTANT! Model.defaults must be an object to use attribute type annotations features described here.\r\ndefaults function body is supported for backward compatibility with backbone only, in order to simplify transition.\r\n\r\nType specs can be optionally used instead of init values in Model.defaults. They looks like this:\r\n\r\n    name : Constructor\r\n\r\nor\r\n\r\n    name : Constructor.value( x )\r\n\r\nwhere Constructor is JS constructor function, and x is its default value.\r\n\r\nWhen default value is not specified, typed attribute is initialized invoking 'new Constructor()'.\r\n\r\nAs a general rule, when typed attribute is assigned with the value...\r\n- which is null, attribute will be set to null.\r\n- which is an instance of Constructor, attribute's value will be replaced.\r\n- in other case, NestedTypes will try to convert value to the Constructor type, typically invoking \"new Constructor( value )\". This type conversion algorithm may be overriden for some selected types.\r\n\r\nWhen receiving data from server, type cast logic is used to parse JSON responce; typically you don't need to override Model.parse.\r\n\r\nWhen sending data to the server, Constructor.toJSON will be invoked to produce JSON for typed attributes, so you don't need to override Model.toJSON for that.\r\n\r\n```javascript\r\nvar A = Nested.Model.extend({\r\n    defaults : {\r\n        obj1 : Ctor, // = new Ctor()\r\n        obj2 : Ctor.value( null ), // = null\r\n        obj3 : Ctor.value( something ), // = new Ctor( something )\r\n    }\r\n});\r\n\r\nvar a = A();\r\n\r\na.obj2 = \"dsds\"; // a.obj2 = new Ctor( \"dsds\" );\r\n\r\nconsole.assert( a.obj2 instanceof Ctor );\r\n```\r\n\r\n### Primitive types (Boolean, Number, String, Integer)\r\n\r\nPrimitive types are special in a sense that *they are inferred from their values*, so they are always typed. In most cases special type annotation syntax is not really required.\r\n\r\nIt means that if attribute has default value of 5 *then it's guaranteed to be Number or null* (it will be casted to Number on assignments). This is quite different from original Backbone's behaviour which you might expect, and it makes models safer. For polimorphic attributes holding different types you can disable type inference using 'Nested.value'.\r\n\r\nIMPORTANT! Although it's not possible to use type annotations in Model.defaults function body, primitive types will be inferred from their values in this case. So beware.\r\n\r\nNestedTypes adds global Integer type, to be used in type annotations. It behaves the same as Number, but convert values to integer on attribute assignment using Math.round. Integer type is not being inferred from the values, and needs to be specified explicitly.\r\n\r\n```javascript\r\nvar A = Nested.Model.extend({\r\n    defaults : {\r\n        // Original backbone behaviour - no type, value is 3232\r\n        untyped : Nested.value( 3232 )\r\n\r\n        // defaults with primitive types are always 'typed'\r\n        number  : 5,           // same as Number.value( 5 )\r\n        integer : Integer.value( 6 ),\r\n        string  : 'something', // same as String.value( 'something' )\r\n        string1 : '',          // same as String\r\n        boolean : true,        // same as Boolean.value( true )\r\n\r\n        initWithNull  : String.value( null ), // Type is String, default value is null\r\n    }\r\n});\r\n\r\nvar a = A();\r\n\r\na.boolean = \"hello\";\r\nconsole.assert( a.boolean === true );\r\n\r\na.number = \"5\";\r\nconsole.assert( a.number === 5 );\r\n\r\na.number = \"hjhjfd\";\r\nconsole.assert( _.isNaN( a.number ) );\r\n\r\na.integer = 1.5423;\r\nconsole.assert( a.integer === 2 );\r\n\r\na.string = 5;\r\nconsole.assert( a.string === \"5\" );\r\n\r\na.boolean = 0;\r\nconsole.assert( a.boolean === false );\r\n```\r\n\r\n### Date type\r\n- Automatic parsing of common JSON date representations.\r\n- Automatically serialized to ISO string (don't need to override toJSON)\r\n\r\nDate attributes free you from overriding Model.parse or Model.toJSON when you want to transfer dates between server and client.\r\n\r\nStrings and numbers will be converted to date with Date constructor. NestedTypes contains additional logic to implement cross-browser ISO date parsing and handling of MS date format.\r\n\r\nOn serialization, Date.toJSON will be invoked for date attribute, producing UTC-0 ISO date string representation.\r\n\r\n```javascript\r\nvar A = Nested.Model.extend({\r\n    defaults : {\r\n        created : Date, // = new Date()\r\n        updated : Date.value( null ), // = null\r\n        a : Date.value( 327943789 ), //  = new Date( 327943789 )\r\n        b : Date.value( \"2012-12-12 12:12\" ) //  = new Date( \"2012-12-12 12:12\" )\r\n    }\r\n});\r\n\r\nvar a = A();\r\n\r\na.updated = '2012-12-12 12:12';\r\nconsole.assert( a.updated instanceof Date );\r\n\r\na.updated = '/Date(32323232323)/';\r\nconsole.assert( a.updated instanceof Date );\r\n```\r\n\r\n### Nested Models and Collections\r\n- automatic parsing and serialization\r\n- 'deep updates' and 'deep clone'\r\n- 'change' event bubbling\r\n\r\nTo define nested model or collection, just annotate attributes with Model or Collection type.\r\n\r\nNote, that Backbone's .clone() method will create shallow copy of the root model, while Model.deepClone() and Collection.deepClone() will clone model and collection with all subitems.\r\n\r\n```javascript\r\nvar User = Nested.Model.extend({\r\n    defaults : {\r\n        name        : String,\r\n        created     : Date,\r\n        group       : GroupModel,\r\n        permissions : PermissionCollection\r\n    }\r\n});\r\n\r\nvar a = new User(),\r\n    b = a.deepClone();\r\n```\r\n\r\nModel/Collection type cast behavior depends on attribute value before assignment:\r\n- If attribute value is null, Model/Collection constructor will be invoked as for usual types.\r\n- If attribute already holds model or collection, *deep update* will be performed instead.\r\n\r\n\"Deep update\" means that model/collection object itself will remain in place, and 'set' method will be used to perform an update.\r\n\r\nI.e. this code:\r\n\r\n```javascript\r\nvar user = new User();\r\nuser.group = {\r\n    name: \"Admin\"\r\n};\r\n\r\nuser.permissions = [{ id: 5, type: 'full' }];\r\n```\r\n\r\nis equivalent of:\r\n\r\n```javascript\r\nuser.group.set({\r\n   name: \"Admin\"\r\n};\r\n\r\nuser.permissions.set( [{ id: 5, type: 'full' }] );\r\n```\r\n\r\nThis mechanics of 'set' allows you to work with JSON from in case of deeply nested models and collections without the need to override 'parse'. This code (considering that nested attributes defined as models):\r\n\r\n```javascript\r\nuser.group = {\r\n    nestedModel : {\r\n        deeplyNestedModel : {\r\n            attr : 'value'\r\n        },\r\n\r\n        attr : 5\r\n    }\r\n};\r\n```\r\n\r\nis almost equivalent of:\r\n\r\n```javascript\r\nuser.group.nestedModel.deeplyNestedModel.set( 'attr', 'value' );\r\nuser.group.nestedModel.set( 'attr', 'value' );\r\n```\r\n\r\nbut it will fire just single `change` event.\r\n\r\nChange events will be bubbled from nested models and collections.\r\n- `change` and `change:attribute` events for any changes in nested models and collections. Multiple `change` events from submodels during bulk updates are carefully joined together, which make it suitable to subscribe View.render to the top model's `change`.\r\n- `replace:attribute` event when model or collection is replaced with new object. You might need it to subscribe for events from submodels.\r\n- It's possible to control event bubbling for every attribute. You can completely disable it, or override the list of events which would be counted as change:\r\n\r\n```javascript\r\nvar M = Nested.Model.extend({\r\n\tdefaults: {\r\n\t\tbubbleChanges : ModelOrCollection,\r\n\r\n\t\tdontBubble : ModelOrCollection.options({ triggerWhanChanged : false })\r\n\t\t}),\r\n\r\n\t\tbubbleCustomEvents : ModelOrCollection.options({\r\n            triggerWhanChanged : 'event1 event2 whatever'\r\n\t\t}),\r\n\t}\r\n});\r\n```\r\n\r\n### Attribute options\r\n- type and value\r\n- override native property\r\n- override parse/toJSON\r\n\r\nAttribute options spec allow for a full control on the attribute options, including 'type' and 'value'. Attribute type specification is the special case of options spec, which, in its most general form, looks like this:\r\n\r\n    Nested.options({ ... })\r\n\r\nThe relation between short and long forms of attribute options spec is summarized in the table below:\r\n\r\n Short form              | Long form\r\n-------------------------|-------\r\n Type                    | Nested.options({ type : Type })\r\n Type.options({ ... })   | Nested.options({ type : Type, ... })\r\n Nested.value( x )  | Nested.options({ value : x })\r\n Type.value( x )         | Nested.options({ type : Type, value: x })\r\n\r\n\r\nBoth long and short forms of attribute options are chainable. I.e. following constructs are possible:\r\n\r\n    Type.value( x ).options({ ... }) // same as Nested.options({ type : Type, value : x, ... })\r\n    Nested.value( x ).options({ ... }) // = Nested.options({ value : x, ... })\r\n    Nested.options({ ... }).value( x ) // = Nested.options({ value : x, ... })\r\n    ...\r\n\r\nAvailable options so far are:\r\n\r\n#### type\r\n```\r\ntype : Ctor\r\n```\r\nAttribute's type (constructor function). When no type is provided, attribute behaves as regular backbone attribute.\r\n\r\n#### value\r\n```\r\nvalue : x\r\n```\r\nAttribute's default value. When type is specified, value will be casted to this type on construction.\r\n\r\n#### toJSON\r\n```\r\ntoJSON : function( attrValue, attrName ){ return attrValue.toJSON(); }\r\nor\r\ntoJSON : false\r\n```\r\nWhen attribute will be serialized as a part of model, given function will be used *instead* of attribute's toJSON.\r\nFunction will be executed in the context of the model.\r\n\r\nSpecifying 'false' will prevent attribute form serialization.\r\n\r\n#### parse\r\n```\r\nparse  : function( data ){ return data; }\r\n\r\n```\r\nWhen attribute is parsed as a part of the model, given function will be called *before* calling the attribute's parse.\r\n\r\n#### get hook\r\n\r\n    get : function( value ){ return value; }\r\n\r\nCalled on Model.get in the context of the model, allowing you to modify returned value.\r\n\r\n#### set hook\r\n\r\n    set : function( value, options ){ return value; }\r\n\r\nCalled on Model.set in the context of the model, allowing you to modify value before set ot cancel setting of the attribute, returning 'undefined'.\r\n\r\nset hook is executed on every attribute change, *after* type cast. So, it's guaranteed that value will be of the correct type.\r\n\r\nFor nested models and collections it will be called only in case when model/collection\r\n instance will be replaced, which makes it a perfect place to handle custom events subscriptions.\r\n\r\n#### property\r\n    property : function( name ){\r\n        return {\r\n            get : function(){\r\n                return this.attribute[ name ];\r\n            },\r\n\r\n            set: function( value ){\r\n                this.set( name, value );\r\n                return value;\r\n            }\r\n        }\r\n    }\r\n\r\nor\r\n\r\n    property : false\r\n\r\nThis option is used to override attribute's native property. 'false' option will disable native property generation for this attribute.\r\n\r\nIt's low level, so use it with extreme care.\r\n\r\n#### triggerWhenChanged\r\n\r\n    triggerWhenChanged : String\r\n    or\r\n    triggerWhenChanged : false\r\n\r\ntrigger 'change' event on the model when given list of events are triggered by the attribute.\r\nSpecify 'false' to turn off event bubbling.\r\n\r\nOne-to-many and many-to-many model relationships\r\n--------------------------\r\n\r\nSometimes when you have one-to-many and many-to-many relationships between Models, it is suitable to transfer such a relationships from server as arrays of model ids. NestedTypes gives you special attribute data types for this situation.\r\n\r\n```javascript\r\nvar User = Nested.Model.extend({\r\n    defaults : {\r\n        name : String,\r\n        roles : RolesCollection.subsetOf( roles ) // <- serialized as array of model ids\r\n        location : Location.from( locations ) // <- serialized as model id\r\n    }\r\n});\r\n\r\nvar user = new User({ id: 0 });\r\nuser.fetch(); // <- you'll receive from server \"{ id: 0, name : 'john', roles : [ 1, 2, 3 ] }\"\r\n...\r\n// however, user.roles behaves like normal collection of Roles.\r\nassert( user.roles instanceof Collection );\r\nassert( user.roles.first() instanceof Role );\r\n```\r\n\r\nCollection.subsetOf is a collection of models taken from existing collection. On first access of attribute of this type, it will resolve ids to real models from the given master collection.\r\n\r\nIf master collection is empty and thus references cannot be resolved, it will defer id resolution and just return empty collection or null. If master collection is not empty, it will filter out ids of non-existent models.\r\n\r\nMaster collection reference may be:\r\n- direct reference to collection object\r\n- string, designating reference to the current model's member relative to 'this'.\r\n- function, which returns reference to collection and executed in the context of the current model.\r\n\r\n\r\n```javascript\r\nvar User = Nested.Model.extend({\r\n    defaults : {\r\n        name : String,\r\n        roles : Collection.subsetOf( 'collection.roles' ); // this.collection.roles\r\n        location : Location.from( function(){ return this.collection.locations; }); // this.collection.locations\r\n    }\r\n});\r\n```\r\n\r\nThere's a global store for the collections, which might be useful in case of bi-directional relationships. It's available as a member of Model (this.store), and globally as Nested.store.\r\n\r\nStore needs to be initialized with a hash of collections and models type specs. It can be initialized several times. On first access to every member of the store, it will fetch data from the server automatically. You need to take care of update events.\r\n\r\n```javascript\r\nNested.store = {\r\n    roles : Role.Collection,\r\n    locations : Locations.Collection\r\n}\r\n\r\nvar User = Nested.Model.extend({\r\n    defaults : {\r\n        name : String,\r\n        roles : Collection.subsetOf( 'store.roles' ); // this.store.roles\r\n        location : Location.from( function(){ return this.store.locations; }); // this.store.locations\r\n    }\r\n});\r\n```\r\n\r\nStore behaves as regular model, but provide some additional methods:\r\n- fetch() will update all store members, which are loaded.\r\n- fetch( 'name1', 'name2', ... ) will fetch listed members and return promise.\r\n- clear() will clear all collections in store and return store to allow chained calls.\r\n- clear( 'name1', 'name2', ... ) will clear listed members.\r\n\r\nNote, that 'change' events won't be bubbled from models in Collection.subsetOf. Other collection's events will.\r\n\r\nFor Model.from attribute no model changes will be bubbled.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}