{"name":"Backbone.nestedtypes","tagline":"Backbone.js extension adding native properties for models, defaults' type annotations, nested models and collections.","body":"backbone.nestedTypes\r\n====================\r\n\r\nIn case you're precisely know what you're looking for, it's backbone.js extension adding type annotations to model attributes, easiest possible way of dealing with nested models and collections, and native properties for attributes. Providing you with a more or less complete, simple, and powerful object system for JavaScript.\r\n\r\nIn case if you don't, here is a brief outline of problems we're solving with this little thing. There are two major goals behind:\r\n\r\n1. Simplify maping of complex server-side entities to client's models. It should:\r\n    - free you from writing type convertion code inside of `parse`, `toJSON`, and `initialize`. It's _not_ trivial thing to do it right.\r\n    - automatically handle nested JSON objects.\r\n    - automatically handle simple types, such as Date.\r\n    - behave well for inherited models as well.\r\n    - Provide really easy way to handle different type of model's relations. Should have zero learingn curve. As we think, the way how it's done in backbone.relational is too restrictive and is an overkill for most applications.\r\n\r\n2. Simplify usage of models as contexts for template rendering. What we've done for that:\r\n    - support for nested models is mandatory, since view-models are usually hold the set of different models.\r\n    - implement event bubbling from nested models and collections _right_. It means, for example, that in case of bulk collection change with collection.set upper level model should trigger 'change' event only once. Very helpful, if you like to render you view in case of model's change.\r\n    - automatic generation of native JS properties, to make templates look good.\r\n\r\nThese issues are addressed in many different backbone plugins, but this one is defferent.\r\n\r\nWe solve these problems encouraging you to type less, than you used to. 'Type specs' in model's 'defaults' section do all the magic. So, if your attribute is a date, just write in defaults, that it's Date. That's it. No, you don't need a compiler, it's still old good vanilla JS you're get used to.\r\n\r\nModel's native properties\r\n-------------------------\r\nForget the 'get'. For any model attributes mentioned in 'defaults', use\r\n\r\n```javascript\r\nmodel.first = model.second;\r\nmodel.deep.nesting = some.thing.from.another.model;\r\n```\r\n\r\ninstead of\r\n\r\n```javascript\r\nmodel.set( 'first', model.get( 'second' ) );\r\nmodel.deep.set( 'nesting', some.get( 'thing' ).get( 'from' ).get( 'another' ).get( 'model );\r\n```\r\n\r\nGreat for accessing nested models from templates.\r\n\r\nAlso, you can define calculated native properties for models and collections like this:\r\n\r\n```javascript\r\nvar MyModel = Model.extend({\r\n    defaults : {\r\n        otherModel_id : 0,\r\n        yetAnotherModel_id : 2\r\n    },\r\n\r\n    __otherModelsCollection : null,\r\n\r\n    properties : {\r\n        otherModel : function(){\r\n            return this.__otherModelsCollection.get( this.otherModel_id );\r\n        },\r\n\r\n        yetAnotherModel : {\r\n            get : function(){\r\n                return this.__otherModelsCollection.get( this.yetAnotherModel_id );\r\n            },\r\n\r\n            set : function( model ){\r\n                this.yetAnotherModel_id = model.id;\r\n            }\r\n        }\r\n    }\r\n});\r\n\r\n// This could be done from some other place...\r\nMyModel.prototype.__otherModelsCollection = ...\r\n```\r\n\r\nGreat for implementing collection joins which looks like nested models. Also, since custom properties definition override default properties, it's well suitable for setting hooks on attribute's modification. In case you'll need such a weird stuff, of course.\r\n\r\nType annotations for Model attributes\r\n-------------------------------------\r\n\r\nYou could use constructor functions as default value.\r\n\r\n```javascript\r\nvar User = Model.extend({\r\n    defaults : {\r\n        name : String,\r\n        created : Date,\r\n        loginCount: Number\r\n    }\r\n});\r\n```\r\n\r\nNew object will be created automatically for any typed attribute, no need to override `initialize`.\r\n When typed attribute assigned with value of different type, constructor will be invoked to\r\nconvert it to defined type.\r\n\r\n```javascript\r\nvar user = new User();\r\nassert( user.created instanceof Date );\r\n\r\nuser.created = \"2012-12-12 12:12\"; // string will be converted to Date\r\nassert( user.created instanceof Date );\r\n\r\nuser.loginCount = \"jhkhjhjhj\";\r\nassert( user.loginCount === NaN );\r\n```\r\n\r\nIt means, that you don't need to override Model.parse and Model.initialize when you receive time and\r\n date from the server. It will be parsed and serialized to JSON as ISO date automatically.\r\n\r\nNested Models and Collections\r\n-----------------------------\r\n\r\nTo have nested models and collections, annotate attribute with Model or Collection type.\r\n\r\n```javascript\r\nvar User = Model.extend({\r\n    defaults : {\r\n        name : String,\r\n        created : Date,\r\n        group : GroupModel,\r\n        permissions : PermissionCollection\r\n    }\r\n});\r\n```\r\n\r\nNo need to override `initialize`, `parse`, and `toJSON`, everything will be done automatically.\r\n\r\nThere is a difference from regular types in 'set' behaviour. If attribute's current value is not null,\r\nand new value has different type, it will be delegated to 'set' method of nested model or collection.\r\nI.e. this code:\r\n\r\n```javascript\r\nvar user = new User();\r\nuser.group = {\r\n    name: \"Admin\"\r\n};\r\n\r\nuser.permissions = [{ id: 5, type: 'full' }];\r\n```\r\n\r\nis equivalent of:\r\n\r\n```javascript\r\nuser.group.set({\r\n   name: \"Admin\"\r\n};\r\n\r\nuser.permissions.set( [{ id: 5, type: 'full' }] );\r\n```\r\n\r\nThis mechanics of 'set' allows you to work with JSON from in case of deeply nested models and collections without the need to override 'parse'. This code (considering that nested attributes defined as models):\r\n\r\n```javascript\r\nuser.group = {\r\n    nestedModel : {\r\n        deeplyNestedModel : {\r\n            attr : 'value'\r\n        },\r\n        \r\n        attr : 5\r\n    }\r\n};\r\n```\r\n    \r\nis almost equivalent of:\r\n\r\n```javascript\r\nuser.group.nestedModel.deeplyNestedModel.set( 'attr', 'value' );\r\nuser.group.nestedModel.set( 'attr', 'value' );\r\n```\r\n    \r\nbut it will fire just single `change` event.\r\n\r\nChange events will be bubbled from nested models and collections.\r\n- `change` and `change:attribute` events for any changes in nested models and collections. Multiple `change` events from submodels during bulk updates are carefully joined together, which make it suitable to subscribe View.render to the top model's `change`.\r\n- `replace:attribute` event when model or collection is replaced with new object. You might need it to subscribe for events from submodels.\r\n\r\nOther enhancements\r\n------------------\r\n- deepClone operation for deep copy of nested models, collections, and types. When you start working with nested stuff seriously, you'll need it soon.\r\n \r\n```javascript\r\nmodel.nestedModel = other.nestedModel.deepClone(); // will create a copy of nested objects tree\r\n```\r\n\r\n- Default attributes are being inherited from the base model. In vanilla backbone, base model defaults will be completely overriden by subclass, which is annoying.\r\n```javascript\r\nvar Base = Model.extend({\r\n\tdefaults: {\r\n\t\ta : 1\r\n\t}\r\n});\r\n\r\nvar Derived = Base.extend({\r\n\tdefaults: {\r\n\t\tb : 1\r\n\t}\r\n});\r\n\r\nvar instance = new Derived();\r\nassert( instance.b === 1 );\r\nassert( instance.a === 1 );\r\n```\r\n- Class type, which can send and receive Backbone events and can be extended. Also, it can have native properties, as Model and Collection. The basic building block of Backbone, which was not exported from the library directly for some reason.\r\n\r\n```javascript\r\nvar myClass = Class.extend({\r\n\ta : 1,\r\n\r\n\tinitialize : function( options ){\r\n\t\tthis.a = options.a\r\n\t},\r\n\r\n\tproperties : {\r\n\t\tb : function(){ return this.a + 1; }\r\n\t}\r\n});\r\n```\r\nInstallation and dependencies\r\n-----------------------------\r\nYou need a single file (nestedtypes.js) and backbone.js itself. It should work in browser with plain script tag,\r\nrequire.js or other AMD loader. Also, it's available as npm package for node.js (https://www.npmjs.org/package/backbone.nested-types).\r\n\r\nModule exports three variables - Class, Model, Collection. You need to use them instead of backbone's.\r\n\r\nAnd yes, you could expect this extension to be bug free enough to use. It is being developed as a part of commercial product. Volicon rely on this extension as a core part of architecture for next gen products. And we're actually interested in your bug reports. :)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}