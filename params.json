{"name":"Backbone.nestedtypes","tagline":"Backbone.js extension adding native properties for models, defaults' type annotations, nested models and collections.","body":"IMPORTANT. There changes in verion 9.x which is not compatible with previous versions. Following changes in code will be required:\r\n- NestedTypes.Attribute({ ... }) -> NestedTypes.options({ ... })\r\n- NestedTypes.Attribute( Type, value ) -> Type.value( value )\r\n\r\nSee \"Attribute options\" section for details on new type annotation syntax.\r\n\r\nbackbone.nestedTypes\r\n====================\r\n\r\nNestedTypes is the type system for JavaScript, implemented on top of  Backbone. It solve common architectural problems of Backbone applications, providing simple yet powerful tools to deal with complex nested data structures. Brief feature list:\r\n\r\n- Class type\r\n- *Native properties* for Model attributes, Collection, and Class.\r\n- Inline Collection definition syntax for Models.\r\n- Model.defaults inheritance and deep copying.\r\n- Type declarations and automatic type casts for Model attributes.\r\n- Easy handling of Date attributes.\r\n- *Nested models* and collections.\r\n- *One-to-many* and *many-to-many* models relations.\r\n- 'change' event bubbling for nested models and collections.\r\n- Attribute-level control for parse/toJSON and event bubbling.\r\n- Run-time type error detection and logging.\r\n\r\nHow it feels like\r\n-----------------\r\n\r\nIt feels much like statically typed programming language. Yet, it's vanilla JavaScript.\r\n\r\n```javascript\r\nvar User = NestedTypes.Model.extend({\r\n    urlRoot : '/api/users',\r\n\r\n    defaults : {\r\n        // Primitive types\r\n        login    : String, // = \"\"\r\n        email    : String.value( null ), // = null\r\n        loginCount : Number.options({ toJSON : false }) // = 0, not serialized\r\n        active   : Boolean.value( true ), // = true\r\n\r\n        created  : Date, // = new Date()\r\n\r\n        settings : Settings, // nested model\r\n\r\n        // collection of models, received as an array of model ids\r\n        roles    : Role.Collection.SubsetOf( rolesCollection ),\r\n        // reference to model, received as model id.\r\n        office : Office.From( officeCollection )\r\n    }\r\n});\r\n\r\nvar collection = new User.Collection(); // Collection is already there...\r\ncollection.fetch().done( function(){\r\n    var user = collection.first();\r\n    console.log( user.name ); // native properties\r\n    console.log( user.office.name );\r\n    console.log( user.roles.first().name );\r\n});\r\n```\r\n\r\nTypes are being checked in run-time on assignment, but instead of throwing exceptions it tries to cast values to defined types. For example:\r\n\r\n```javascript\r\n    user.login = 1;\r\n    console.assert( user.login === \"1\" );\r\n\r\n    user.active = undefined;\r\n    console.assert( user.active === false );\r\n\r\n    user.loginCount = \"hjkhjkhfjkhjkfd\";\r\n    console.assert( _.isNan( user.loginCount ) );\r\n\r\n    user.settings = { timeZone : 180 }; // same as user.settings.set({ timeZone : 180 })\r\n    console.assert( user.settings instanceof Settings );\r\n```\r\n\r\nRequirements & Installation\r\n---------------------------\r\n\r\nAll modern browsers and IE9+ are supported. To install, type\r\n\r\n    bower install backbone.nested-types\r\n\r\nor\r\n\r\n    npm install backbone.nested-types\r\n\r\nor just copy 'nestedtypes.js' file to desired location.\r\n\r\nNestedTypes is compatible with node.js, CommonJS/AMD (e.g. RequireJS) module loaders, and could be included with plain script tag as well. To include it, use\r\n\r\n    var NestedTypes = require( 'nestedtypes');\r\n\r\nor\r\n\r\n    require([ 'nestedtypes' ], function( NestedTypes ){\r\n\r\nor\r\n\r\n    <script src=\"nestedtypes.js\" type=\"text/javascript\"></script>\r\n\r\n\r\n# API Reference\r\n## Basic features\r\n### Model.defaults:\r\n- Native properties are created for every entry.\r\n- Entries are inherited from the base Model.defaults.\r\n- JSON literals will be deep copied upon creation of model.\r\n- defaults *must* be an object, functions are not supported.\r\n- attributes *must* be declared in defaults.\r\n\r\n\r\n```javascript\r\n    var UserInfo = NestedTypes.Model.extend({\r\n        defaults : {\r\n            name : 'test',\r\n        }\r\n    });\r\n\r\n    var DetailedUserInfo = UserInfo.extend({\r\n        defaults : {\r\n            login : '',\r\n            roles : [ 'user' ]\r\n        }\r\n    });\r\n\r\n    var user = new DetailedUserInfo();\r\n\r\n    // user.get( 'name' ) would be undefined in plain Backbone.\r\n    console.assert( user.name === 'test' ); // you still can use 'get', but why...\r\n    user.name = 'admin';\r\n\r\n    // In Backbone all models will share the same instance of [ 'user' ] array.\r\n    // So, following line will create a bug. Not in NestedTypes.\r\n    user.roles.push( 'admin' );\r\n```\r\n\r\n### Inline collection definition (Model.collection).\r\n\r\nBy the way, our models from previous example has collections defined already.\r\n```javascript\r\n    var users = new UserInfo.Collection();\r\n    var detailedUsers = new DetailedUserInfo.Collection();\r\n```\r\n\r\nEvery model definition creates Collection type extending base Model.Collection.  Collection.model and Collection.url properties are taken from model. You could customize collection with a spec in Model.collection, which then will be passed to BaseModel.Collection.extend.\r\n\r\n```javascript\r\nvar DetailedUserInfo = UserInfo.extend({\r\n    urlBase : '/api/detailed_user/',\r\n\r\n    defaults : {\r\n        login : '',\r\n        roles : [ 'user' ]\r\n    },\r\n\r\n    collection : {\r\n        initialize : function(){\r\n            this.fetch();\r\n        }\r\n    }\r\n});\r\n\r\n/*\r\n    DetailedUserInfo.Collection = UserInfo.Collection.extend({\r\n        url : '/api/detailed_user/',\r\n        model : DetailedUserInfo,\r\n\r\n        initialize: function(){\r\n            this.fetch();\r\n        }\r\n    });\r\n*/\r\n```\r\n\r\n### Class type, which can be extended and can throw/listen to events.\r\n\r\n```javascript\r\n    var A = NestedTypes.Class.extend({\r\n        a : 1,\r\n\r\n        initialize : function( options ){\r\n            this.listenTo( options.other, 'event', doSomething )\r\n        },\r\n\r\n        doSomething : function(){\r\n            this.trigger( 'something' );\r\n        }\r\n    });\r\n\r\n    var B = A.extend({\r\n        b : 2,\r\n\r\n        initialize : function( options ){\r\n            A.prototype.initialize.apply( this, arguments );\r\n            this.listenTo( options.another, 'event', doSomething )\r\n        },\r\n    });\r\n\r\n    var b = new B( options );\r\n```\r\n\r\n### Explicit native properties definition (Model, Class, Collection).\r\n\r\nNative properties are generated for model attributes, however, they also can be defined explicitly for Model, Class, Collection with 'properties' specification.\r\n\r\nFor Model, explicit property will override generated one, and \"properties : false\" disable defaults native properties generation.\r\n\r\n```javascript\r\n    var A = NestedTypes.Model.extend({\r\n        defaults : {\r\n            a : 1,\r\n            b : 2\r\n        },\r\n\r\n        properties : {\r\n            c : function(){\r\n                return this.a + this.b;\r\n            },\r\n\r\n            ax2 : {\r\n                get : function(){\r\n                    return this.a * 2;\r\n                },\r\n\r\n                set : function( value ){\r\n                    this.a = value / 2;\r\n                    return value;\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    var a = new A();\r\n    console.assert( a.c === 3 );\r\n\r\n    a.ax2 = 4;\r\n    console.assert( a.c === 2 );\r\n```\r\n\r\n### Run-time errors\r\n\r\nNestedTypes detect four error types in the runtime, which will be logged to console using console.error.\r\n\r\n```\r\n[Type error](Model.extend) Property \"name\" conflicts with base class members.\r\n```\r\nIt's forbidden for native properties to override members of the base Model. Since native properties are generated for Model.defaults elements, its also forbidden to have attribute names which are the same as members of the base Model.\r\n\r\n```\r\n[Type Error](Model.set) Attribute hash is not an object: ...\r\n```\r\nFirst argument of Model.set must be either string, or literal object representing attribute hash.\r\n\r\n```\r\n[Type Error](Model.set) Attribute \"name\" has no default value.\r\n```\r\nAttempt to set attribute which is not declared in defaults.\r\n\r\n```\r\n[Type Error](Model.defaults) \"defaults\" must be an object, functions are not supported\r\n```\r\n\r\n## Model.defaults Type Specs\r\n### Basic type annotation syntax and rules\r\n\r\nType specs can be optionally used instead of init values in Model.defaults. They looks like this:\r\n\r\n    name : Constructor\r\n\r\nor\r\n\r\n    name : Constructor.value( x )\r\n\r\nwhere Constructor is JS constructor function, and x is its default value.\r\n\r\nWhen default value is not specified, typed attribute is initialized invoking 'new Constructor()'.\r\n\r\nAs a general rule, when typed attribute is assigned with the value...\r\n- which is null, attribute will be set to null.\r\n- which is an instance of Constructor, attribute's value will be replaced.\r\n- in other case, NestedTypes will try to convert value to the Constructor type, typically invoking \"new Constructor( value )\". This type conversion algorithm may be overriden for some selected types.\r\n\r\nWhen receiving data from server, type cast logic is used to parse JSON responce; typically you don't need to override Model.parse.\r\n\r\nWhen sending data to the server, Constructor.toJSON will be invoked to produce JSON for typed attributes, so you don't need to override Model.toJSON for that.\r\n\r\n```javascript\r\nvar A = NestedTypes.Model.extend({\r\n    defaults : {\r\n        obj1 : Ctor, // = new Ctor()\r\n        obj2 : Ctor.value( null ), // = null\r\n        obj3 : Ctor.value( something ), // = new Ctor( something )\r\n    }\r\n});\r\n\r\nvar a = A();\r\n\r\na.obj2 = \"dsds\"; // a.obj2 = new Ctor( \"dsds\" );\r\n\r\nconsole.assert( a.obj2 instanceof Ctor );\r\n```\r\n\r\n### Primitive types (Boolean, Number, String)\r\n\r\nPrimitive types are special in a sense that *they are infered from their values*, so they are always typed. In most cases special type annotation syntax is not really required.\r\n\r\nIt means that if attribute has default value of 5 *then it's guaranteed to be Number or null* (it will be casted to Number on assignments). This is quite different from original Backbone's behaviour which you might expect, and it makes models safer. For polimorphic attributes holding different types you can disable type inference using 'NestedTypes.value'.\r\n\r\n```javascript\r\nvar A = NestedTypes.Model.extend({\r\n    defaults : {\r\n        // Original backbone behaviour - no type, value is 3232\r\n        untyped : NestedTypes.value( 3232 )\r\n\r\n        // defaults with primitive types are always 'typed'\r\n        number  : 5,           // same as Number.value( 5 )\r\n        string  : 'something', // same as String.value( 'something' )\r\n        string1 : '',          // same as String\r\n        boolean : true,        // same as Boolean.value( true )\r\n\r\n        initWithNull  : String.value( null ), // Type is String, default value is null\r\n    }\r\n});\r\n\r\nvar a = A();\r\n\r\na.boolean = \"hello\";\r\nconsole.assert( a.boolean === true );\r\n\r\na.number = \"5\";\r\nconsole.assert( a.number === 5 );\r\n\r\na.number = \"hjhjfd\";\r\nconsole.assert( _.isNaN( a.number ) );\r\n\r\na.string = 5;\r\nconsole.assert( a.string === \"5\" );\r\n\r\na.boolean = 0;\r\nconsole.assert( a.boolean === false );\r\n```\r\n\r\n### Date type\r\n- Automatic parsing of common JSON date representations.\r\n- Automatically serialized to ISO string (don't need to override toJSON)\r\n\r\nDate attributes free you from overriding Model.parse or Model.toJSON when you want to transfer dates between server and client.\r\n\r\nStrings and numbers will be converted to date with Date constructor. NestedTypes contains additional logic to implement cross-browser ISO date parsing and handling of MS date format.\r\n\r\nOn serialization, Date.toJSON will be invoked for date attribute, producing UTC-0 ISO date string representation.\r\n\r\n```javascript\r\nvar A = NestedTypes.Model.extend({\r\n    defaults : {\r\n        created : Date, // = new Date()\r\n        updated : Date.value( null ), // = null\r\n        a : Date.value( 327943789 ), //  = new Date( 327943789 )\r\n        b : Date.value( \"2012-12-12 12:12\" ) //  = new Date( \"2012-12-12 12:12\" )\r\n    }\r\n});\r\n\r\nvar a = A();\r\n\r\na.updated = '2012-12-12 12:12';\r\nconsole.assert( a.updated instanceof Date );\r\n\r\na.updated = '/Date(32323232323)/';\r\nconsole.assert( a.updated instanceof Date );\r\n```\r\n\r\n### Nested Models and Collections\r\n- automatic parsing and serialization\r\n- 'deep updates' and 'deep clone'\r\n- 'change' event bubbling\r\n\r\nTo define nested model or collection, just annotate attributes with Model or Collection type.\r\n\r\nNote, that Backbone's .clone() method will create shallow copy of the root model, while Model.deepClone() and Collection.deepClone() will clone model and collection with all subitems.\r\n\r\n```javascript\r\nvar User = NestedTypes.Model.extend({\r\n    defaults : {\r\n        name        : String,\r\n        created     : Date,\r\n        group       : GroupModel,\r\n        permissions : PermissionCollection\r\n    }\r\n});\r\n\r\nvar a = new User(),\r\n    b = a.deepClone();\r\n```\r\n\r\nModel/Collection type cast behavior depends on attribute value before assignment:\r\n- If attribute value is null, Model/Collection constructor will be invoked as for usual types.\r\n- If attribute already holds model or collection, *deep update* will be performed instead.\r\n\r\n\"Deep update\" means that model/collection object itself will remain in place, and 'set' method will be used to perform an update.\r\n\r\nI.e. this code:\r\n\r\n```javascript\r\nvar user = new User();\r\nuser.group = {\r\n    name: \"Admin\"\r\n};\r\n\r\nuser.permissions = [{ id: 5, type: 'full' }];\r\n```\r\n\r\nis equivalent of:\r\n\r\n```javascript\r\nuser.group.set({\r\n   name: \"Admin\"\r\n};\r\n\r\nuser.permissions.set( [{ id: 5, type: 'full' }] );\r\n```\r\n\r\nThis mechanics of 'set' allows you to work with JSON from in case of deeply nested models and collections without the need to override 'parse'. This code (considering that nested attributes defined as models):\r\n\r\n```javascript\r\nuser.group = {\r\n    nestedModel : {\r\n        deeplyNestedModel : {\r\n            attr : 'value'\r\n        },\r\n\r\n        attr : 5\r\n    }\r\n};\r\n```\r\n\r\nis almost equivalent of:\r\n\r\n```javascript\r\nuser.group.nestedModel.deeplyNestedModel.set( 'attr', 'value' );\r\nuser.group.nestedModel.set( 'attr', 'value' );\r\n```\r\n\r\nbut it will fire just single `change` event.\r\n\r\nChange events will be bubbled from nested models and collections.\r\n- `change` and `change:attribute` events for any changes in nested models and collections. Multiple `change` events from submodels during bulk updates are carefully joined together, which make it suitable to subscribe View.render to the top model's `change`.\r\n- `replace:attribute` event when model or collection is replaced with new object. You might need it to subscribe for events from submodels.\r\n- It's possible to control event bubbling for every attribute. You can completely disable it, or override the list of events which would be counted as change:\r\n\r\n```javascript\r\nvar M = NestedTypes.Model.extend({\r\n\tdefaults: {\r\n\t\tbubbleChanges : ModelOrCollection,\r\n\r\n\t\tdontBubble : ModelOrCollection.options({ triggerWhanChanged : false })\r\n\t\t}),\r\n\r\n\t\tbubbleCustomEvents : ModelOrCollection.options({\r\n            triggerWhanChanged : 'event1 event2 whatever'\r\n\t\t}),\r\n\t}\r\n});\r\n```\r\n\r\n### Model relations\r\n- Model.From\r\n- Collection.SubsetOf\r\n\r\nSometimes when you have one-to-many and many-to-many relationships between Models, it is suitable to transfer such a relationships from server as arrays of model ids. NestedTypes gives you special attribute data types for this situation.\r\n\r\n```javascript\r\nvar User = NestedTypes.Model.extend({\r\n    defaults : {\r\n        name : String,\r\n        roles : RolesCollection.SubsetOf( rolesCollection ) // <- serialized as array of model ids\r\n        location : Location.From( locationsCollection ) // <- serialized as model id\r\n    }\r\n});\r\n\r\nvar user = new User({ id: 0 });\r\nuser.fetch(); // <- you'll receive from server \"{ id: 0, name : 'john', roles : [ 1, 2, 3 ] }\"\r\n...\r\n// however, user.roles behaves like normal collection of Roles.\r\nassert( user.roles instanceof Collection );\r\nassert( user.roles.first() instanceof Role );\r\n```\r\n\r\nCollection.SubsetOf is a collection of models taken from existing collection. On first access of attribute of this type, it will resolve ids to real models from the given master collection.\r\n\r\nIf master collection is empty and thus references cannot be resolved, it will defer id resolution and just return collection of dummy models with ids. However, if master collection is not empty, it will filter out ids of non-existent models.\r\n\r\nThere are 'lazy' option for passing reference to master collection:\r\n\r\n```javascript\r\nvar User = NestedTypes.Model.extend({\r\n    defaults : {\r\n        name : String,\r\n        roles : Collection.RefsTo( function(){\r\n            return this.collection.rolesCollection; // <- collection of Roles is the direct member of Users.Collection\r\n        }),\r\n        location : Location.From( function(){\r\n            return this.collection.locationsCollection; // <- collection of Roles is the direct member of Users.Collection\r\n        })\r\n    }\r\n});\r\n```\r\n\r\nNote, that 'change' events won't be bubbled from models in Collection.SubsetOf. Other collection's events will.\r\n\r\nFor Model.From attribute no model changes will be bubbled.\r\n\r\n### Attribute options\r\n- type and value\r\n- override native property\r\n- override parse/toJSON\r\n\r\nAttribute options spec allow for a full control on the attribute options, including 'type' and 'value'. Attribute type specification is the special case of options spec, which, in its most general form, looks like this:\r\n\r\n    NestedTypes.options({ ... })\r\n\r\nThe relation between short and long forms of attribute options spec is summarized in the table below:\r\n\r\n Short form              | Long form\r\n-------------------------|-------\r\n Type                    | NestedTypes.options({ type : Type })\r\n Type.options({ ... })   | NestedTypes.options({ type : Type, ... })\r\n NestedTypes.value( x )  | NestedTypes.options({ value : x })\r\n Type.value( x )         | NestedTypes.options({ type : Type, value: x })\r\n\r\n\r\nBoth long and short forms of attribute options are chainable. I.e. following constructs are possible:\r\n\r\n    Type.value( x ).options({ ... }) // same as NestedTypes.options({ type : Type, value : x, ... })\r\n    NestedTypes.value( x ).options({ ... }) // = NestedTypes.options({ value : x, ... })\r\n    NestedTypes.options({ ... }).value( x ) // = NestedTypes.options({ value : x, ... })\r\n    ...\r\n\r\nAvailable options so far are:\r\n\r\nOption      | Description\r\n------------|-----------\r\ntype : Ctor | attribute's type (constructor function)\r\nvalue : x   | attribute's default value\r\ntoJSON : false | attribute will not be serialized to JSON\r\ntoJSON : function( attrValue, attrName ) -> JSON | serialize attribute to JSON with the given function\r\nparse  : function( data ) -> {attribute hash} | parse attribute with a given function\r\nget : function() -> value | override native property getter for the attribute\r\nset : function( value ) -> value | to override native property setter for the attribute\r\ntriggerWhenChanged : String | bubble 'change' event when given list of events are triggered by the attribute\r\ntriggerWhenChanged : false  | don't bubble 'change' events from the the attribute\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}